<!DOCTYPE html>
<html lang='en'>
    <head>
        <meta charset='UTF-8'>
        <meta name='viewport' content='width=device-width, initial-scale=1'>
        <title>SNEK</title>
        <link href='https://fonts.googleapis.com/css?family=Saira' rel='stylesheet'>
        <link rel='icon' href='data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>üêç</text></svg>'>
        <!-- <link href='https://cdn.jsdelivr.net/npm/bootstrap-icons@1.9.1/font/bootstrap-icons.css' rel='stylesheet'> -->
    </head>
    <body>

        <canvas id='gameCanvas' width='300' height='300'>something's wrong</canvas>

        <style>
            #gameCanvas {
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                border: 2px solid darkgreen;
            }

            #score {
                text-align: center;
                font-size: 100px;
                font-family: 'Saira', serif;
            }
        </style>
    </body>

    <script>
        const CANVAS_ID = 'gameCanvas';

        const GAME_SPEED = 100;  // milliseconds
        const MVMT_SENSITIVITY =  15;  // degree of motion
        const SWIPE_SENSITIVITY = 10;  // delta of pixels needed to consider touch mvmt a 'swipe'
        const SCORE_INCREMENT = 10;
        const NUM_STEPS_ACROSS_CANVAS = 30;

        const CANVAS_BACKGROUND_COLOR = 'white';
        const CANVAS_BORDER_COLOR = 'darkgreen';
        const SNAKE_COLOR = 'lightgreen';
        const SNAKE_BORDER_COLOR = 'darkgreen';
        const FOOD_COLOR = 'red';
        const FOOD_BORDER_COLOR = 'darkred';
        const GAME_TEXT_COLOR = 'gray';
        const GAME_TEXT_FONT_SIZE = 50;
        const GAME_TEXT_FONT_FAMILY = '"Saira", serif';

        const NO_FILTER = 'none';
        const PAUSE_FILTER = 'contrast(1.4) sepia(1)';
        const ENDGAME_FILTER = 'grayscale(0.8) blur(0.5px)';

        // <!-- DRAWING HELPERS BELOW -->

        /**
         * a fake contextmanager
         * for sharpness https://stackoverflow.com/a/8696641
        **/
        function withStraddle(cb) {
            const offset = 0.5

            try {
                // turn on 'straddle' trick for blurriness
                CTX.translate(offset, offset);
                cb();
            } finally {
                // turn off 'straddle' trick for blurriness
                CTX.translate(-offset, -offset);
            }
        }

        function drawCanvas() {
            withStraddle(() => {
                // set border and background colors
                CTX.filter = ACTIVE_FILTER;
                CTX.fillStyle = CANVAS_BACKGROUND_COLOR;
                CTX.strokeStyle = CANVAS_BORDER_COLOR;
                CTX.fillRect(0, 0, CANVAS.width, CANVAS.height);

                // add full screen icon https://icons.getbootstrap.com/icons/arrows-fullscreen/
                // CTX.font = (25 * RATIO) + 'px "bootstrap-icons"';
                // CTX.fillStyle = 'darkgreen';
                // CTX.fillText(String.fromCharCode(0xF14D), 20 * RATIO, 35 * RATIO);
            });
        }

        function drawSnakePart(snakePart) {
            withStraddle(() => {
                CTX.fillStyle = SNAKE_COLOR;
                CTX.strokeStyle = SNAKE_BORDER_COLOR;
                CTX.fillRect(snakePart.x, snakePart.y, BLOCK_SIZE, BLOCK_SIZE);
                CTX.strokeRect(snakePart.x, snakePart.y, BLOCK_SIZE, BLOCK_SIZE);
            });
        }

        function drawSnake(snake) { snake.forEach(drawSnakePart); }

        function drawFood(food) {
            withStraddle(() => {
                CTX.fillStyle = FOOD_COLOR;
                CTX.strokeStyle = FOOD_BORDER_COLOR;
                CTX.fillRect(food.x, food.y, BLOCK_SIZE, BLOCK_SIZE);
                CTX.strokeRect(food.x, food.y, BLOCK_SIZE, BLOCK_SIZE);
            });
        }

        function drawScore() {
            CTX.font = `${GAME_TEXT_FONT_SIZE * RATIO}px ${GAME_TEXT_FONT_FAMILY}`;
            CTX.textAlign = 'center';
            CTX.fillStyle = GAME_TEXT_COLOR;
            CTX.fillText(SCORE, CANVAS.width / 2, CANVAS.height / 2, CANVAS.width);
        }

        function drawGameEnd() {
            CTX.font = `${GAME_TEXT_FONT_SIZE * RATIO}px ${GAME_TEXT_FONT_FAMILY}`;
            CTX.textAlign = 'center';
            CTX.fillStyle = GAME_TEXT_COLOR;
            CTX.fillText('DED', CANVAS.width / 2, CANVAS.height / 2, CANVAS.width);
        }

        // <!-- EVENT CALLBACKS BELOW -->

        function enterFullScreen() {
            // switch to full screen
            CANVAS.requestFullscreen().then(function () {
                try {
                    // lock portrait orientation when going full screen
                    screen.lockOrientationUniversal = screen.lockOrientation ||
                    screen.mozLockOrientation ||
                    screen.msLockOrientation
                    screen.lockOrientationUniversal('portrait-primary')
                } catch (e) {
                    // console.log(e);
                }
            })
        }

        function exitFullScreen() {
            document.exitFullscreen();
        }

        function changeDirection(keyPressed) {
            if (CHANGING_DIRECTION) { return; }
            CHANGING_DIRECTION = true;

            const LEFT_KEY = 37;
            const RIGHT_KEY = 39;
            const UP_KEY = 38;
            const DOWN_KEY = 40;

            const goingUp = DY === -BLOCK_SIZE;
            const goingDown = DY === BLOCK_SIZE;
            const goingRight = DX === BLOCK_SIZE;
            const goingLeft = DX === -BLOCK_SIZE;

            if (keyPressed === LEFT_KEY && !goingRight) { DX = -BLOCK_SIZE; DY = 0; }
            if (keyPressed === UP_KEY && !goingDown) { DX = 0; DY = -BLOCK_SIZE; }
            if (keyPressed === RIGHT_KEY && !goingLeft) { DX = BLOCK_SIZE; DY = 0; }
            if (keyPressed === DOWN_KEY && !goingUp) { DX = 0; DY = BLOCK_SIZE; }
        }

        function handleSwipeToFullScreen() {
            let downY = 0;
            let upY = 0;

            function handleGesture(ev) {
                if (upY < downY && downY - upY > SWIPE_SENSITIVITY) {
                    // console.log(`swiped UP ${downY-upY}px`);
                    enterFullScreen();
                } else if (upY > downY && upY - downY > SWIPE_SENSITIVITY) {
                    // console.log(`swiped DOWN ${upY-downY}px`);
                    exitFullScreen();
                } else if (IS_END) {
                    restartGame(ev);
                } else {
                    pauseGame();
                }
            }

            function handleTouchStart(ev) {
                ev.preventDefault();

                const firstTouch = ev.changedTouches[0];
                // console.log({
                //     [ev.type]: (firstTouch.screenX, firstTouch.screenY)
                // });
                // downX = firstTouch.screenX;

                downY = firstTouch.screenY;
            }

            function handleTouchEnd(ev) {
                ev.preventDefault();

                const firstTouch = ev.changedTouches[0];
                // console.log({
                //     [ev.type]: (firstTouch.screenX, firstTouch.screenY)
                // });
                // upX = firstTouch.screenX;

                upY = firstTouch.screenY;

                handleGesture(ev);
            }

            CANVAS.addEventListener('touchstart', handleTouchStart);
            CANVAS.addEventListener('touchend', handleTouchEnd);
        }

        function handleUserInput(event) {
            const SPACE_KEY = 32;

            const keyPressed = event.keyCode;

            if (keyPressed === SPACE_KEY) {
                 pauseGame();
            }

            changeDirection(keyPressed);
        }

        function handleDeviceMvmt(event) {
            if (CHANGING_DIRECTION) { return; }
            CHANGING_DIRECTION = true;

            // forward (positive) to backward (negative) motion of the device
            const beta = event.beta;
            // right (positive) to left (negative) motion of the device
            const gamma = event.gamma;

            // console.log('deviceorientation', {
            //     beta: event.beta, last_beta: LAST_BETA, beta_delta: betaDelta,
            //     gamma: event.gamma, last_gamma: LAST_GAMMA, gamma_delta: gammaDelta,
            // });

            const goingUp = DY === -BLOCK_SIZE;
            const goingDown = DY === BLOCK_SIZE;
            const goingRight = DX === BLOCK_SIZE;
            const goingLeft = DX === -BLOCK_SIZE;

            betaDelta = LAST_BETA - beta;
            gammaDelta = LAST_GAMMA - gamma;

            if (betaDelta < -MVMT_SENSITIVITY) {
                if (!goingUp) { dir = 'DOWN'; DX = 0; DY = BLOCK_SIZE; LAST_GAMMA = gamma; }
                LAST_BETA = beta;
            } else if (betaDelta > MVMT_SENSITIVITY) {
                if (!goingDown) { dir = 'UP'; DX = 0; DY = -BLOCK_SIZE; LAST_GAMMA = gamma; }
                LAST_BETA = beta;
            } else if (gammaDelta < -MVMT_SENSITIVITY) {
                if (!goingLeft) { dir = 'RIGHT'; DX = BLOCK_SIZE; DY = 0; LAST_BETA = beta; }
                LAST_GAMMA = gamma;
            } else if (gammaDelta > MVMT_SENSITIVITY) {
                if (!goingRight) { dir = 'LEFT'; DX = -BLOCK_SIZE; DY = 0; LAST_BETA = beta; }
                LAST_GAMMA = gamma;
            }

            // if (dir) {
            //     console.log(`going${dir}`);
            // }
        }

        function handleVisibilityChange() {
            if (document.hidden && !IS_PAUSED) {
                pauseGame();
            }
        }

        // <!-- GAME STATE HELPERS BELOW -->

        function randomBlock(min, max) {
            return Math.round((Math.random() * (max-min) + min) / BLOCK_SIZE) * BLOCK_SIZE;
        }

        function createFood(snake) {
            food = {
                x: randomBlock(0, CANVAS.width - BLOCK_SIZE),
                y: randomBlock(0, CANVAS.height - BLOCK_SIZE)
            };

            snake.forEach(function isFoodOnSnake(part) {
                const foodIsOnSnake = part.x == food.x && part.y == food.y
                if (foodIsOnSnake) food = createFood(snake);
            });

            return food;
        }

        function advanceSnake(snake, food, dx, dy) {
            const head = {x: snake[0].x + dx, y: snake[0].y + dy};
            snake.unshift(head);

            const didEatFood = snake[0].x === food.x && snake[0].y === food.y;

            if (didEatFood) {
                SCORE += SCORE_INCREMENT;
                food = createFood(snake);
            } else {
                snake.pop();
            }

            return food;
        }

        // <!-- GAME EXECUTION HELPERS BELOW -->

        function initGame() {
            // aka define globals

            // define the snake
            SNAKE = [
                {x: CANVAS.width / 2, y: CANVAS.height / 2},
                {x: CANVAS.width / 2 - BLOCK_SIZE, y: CANVAS.height / 2},
                {x: CANVAS.width / 2 - BLOCK_SIZE * 2, y: CANVAS.height / 2},
                {x: CANVAS.width / 2 - BLOCK_SIZE * 3, y: CANVAS.height / 2},
                {x: CANVAS.width / 2 - BLOCK_SIZE * 4, y: CANVAS.height / 2},
            ];

            // set initial snake velocity
            DX = PAUSED_DX = BLOCK_SIZE, DY = PAUSED_DY = 0;
            // if true, snake is changing direction
            CHANGING_DIRECTION = false;
            LAST_BETA = LAST_GAMMA = 0;

            // set initial food placement
            FOOD = createFood(SNAKE);
            // set initial user score
            SCORE = 0;

            IS_PAUSED = false;
            IS_END = false;
            ACTIVE_FILTER = NO_FILTER;
        }

        function pauseGame() {
            IS_PAUSED = !IS_PAUSED;

            if (IS_PAUSED) {
                // save velocity at pause
                PAUSED_DX = DX;
                PAUSED_DY = DY;
                // set velocity to 0
                DX = 0;
                DY = 0;
                // change look of game to 'paused'
                ACTIVE_FILTER = PAUSE_FILTER;
            } else {
                // set velocity to state before pause
                DX = PAUSED_DX;
                DY = PAUSED_DY;
                // remove 'paused' look
                ACTIVE_FILTER = NO_FILTER;
            }
        }

        function restartGame(event) {
            const SPACE_KEY = 32;

            if (event.keyCode === SPACE_KEY || event.type === 'click' || event.type === 'touchend') {
                 document.removeEventListener('keydown', restartGame);
                 document.removeEventListener('click', restartGame);
                 document.addEventListener('keydown', handleUserInput);
                 document.addEventListener('click', pauseGame);

                 initGame();
                 runGame(SNAKE, FOOD);
            }
        }

        function runGame(snake, food) {
            if (didGameEnd(snake)) {
                IS_END = true;
                ACTIVE_FILTER = ENDGAME_FILTER;

                drawCanvas();
                drawFood(food);
                drawSnake(snake);

                drawGameEnd();

                // allow for game restart
                document.removeEventListener('keydown', handleUserInput);
                document.removeEventListener('click', pauseGame);

                document.addEventListener('keydown', restartGame);
                document.addEventListener('click', restartGame);

                return;
            }

            setTimeout(function onTick(){
                CHANGING_DIRECTION = false;

                drawCanvas();
                drawScore();
                drawFood(food);
                if (!IS_PAUSED) {
                    food = advanceSnake(snake, food, DX, DY);
                }
                drawSnake(snake);

                // run game again
                runGame(snake, food);
            }, GAME_SPEED);
        }

        function didGameEnd(snake) {
            // loop starts at index 4 because it is impossible for the first three parts to touch each other
            for (let i = 4; i < snake.length; i++) {
                const didCollide = snake[i].x === snake[0].x && snake[i].y === snake[0].y;
                if (didCollide) { return true; }
            }

            const hitLeftWall = snake[0].x < 0;
            const hitRightWall = snake[0].x > CANVAS.width - BLOCK_SIZE;
            const hitTopWall = snake[0].y < 0;
            const hitBottomWall = snake[0].y > CANVAS.height - BLOCK_SIZE;

            return hitLeftWall || hitRightWall || hitTopWall || hitBottomWall;
        }

        // <!-- MAIN EXECUTION BELOW -->

        // get the canvas element
        const CANVAS = document.getElementById(CANVAS_ID);
        // return a 2d drawing context
        const CTX = CANVAS.getContext('2d');

        // take the min(width, height), find closest number divisible by desired # of total steps across the canvas,
        // and use this as the width + height of the square canvas
        rawSize = Math.min(window.innerWidth, window.innerHeight);
        quotient = parseInt(rawSize / NUM_STEPS_ACROSS_CANVAS);
        // subtracting NUM_STEPS_ACROSS_CANVAS below to allow some whitespace around the game canvas
        adjustedSize = quotient * NUM_STEPS_ACROSS_CANVAS - NUM_STEPS_ACROSS_CANVAS;

        var RATIO = window.devicePixelRatio || 1;
        CANVAS.style.width = adjustedSize + 'px';
        CANVAS.style.height = adjustedSize + 'px';
        CANVAS.width = CANVAS.height = adjustedSize * RATIO;

        let BLOCK_SIZE = CANVAS.width / NUM_STEPS_ACROSS_CANVAS;

        // console.log({
        //     ratio: RATIO, 'canvas.style.width': CANVAS.style.width,
        //     'canvas.style.height': CANVAS.style.height, 'canvas.width': CANVAS.width,
        //     'canvas.height': CANVAS.height, block_size: BLOCK_SIZE
        // })

        // call change direction on key press
        document.addEventListener('keydown', handleUserInput);
        // pause game on click or if game becomes hidden
        document.addEventListener('click', pauseGame);
        document.addEventListener('visibilitychange', handleVisibilityChange, false);
        document.addEventListener('dblclick', enterFullScreen);

        // touch/mobile event stuff
        handleSwipeToFullScreen();
        // TODO: this makes the game less responsive to key press
        window.addEventListener('deviceorientation', handleDeviceMvmt);

        // declare globals to be defined by initGame
        // TODO: it would be nicer not to have globals
        let SNAKE, DX, DY, CHANGING_DIRECTION, LAST_BETA, LAST_GAMMA, FOOD, SCORE, IS_PAUSED, IS_END, ACTIVE_FILTER;

        initGame();
        runGame(SNAKE, FOOD);

        // TODO: extension ideas
            // [from my baby] if snake eats a 'phase' power up (purple), allow snake to go through self once (per power up)
            // if snake eats a 'teleport' power up, allow snake to go through a wall to the opposite side of board once (per power up)
            // some sort of efficiency penalty for 'snaking around' a lot (more blocks travelled, more time spent) ?
            // add sensitity, game speed sliders to UI
            // requestAnimationFrame instead of setTimeout ?
            // high score tracking
            // provide toggle for deviceorientation listener (to make game more responsive)
            // debug mode: extra logging, output info to screen (like canvas dimensions, etc.)
            // "snek refers to images of snakes with interior monologue captioning applied" (knowyourmeme)
                // -- add thought bubbles at random as the snek eats its food?
    </script>
</html>
