{"version":3,"file":"snek.min.js","sources":["../src/js/config.js","../src/js/board.js","../src/js/error.js","../src/js/item.js","../src/js/direction.js","../src/js/motion.js","../src/js/snake.js","../src/js/game/input.js","../src/js/canvas.js","../src/js/game/render.js","../src/js/game/state.js","../src/js/game/game.js","../src/js/main.js"],"sourcesContent":["export const GAME_CONFIG = {\n    BOARD: {\n        CTRL_PANEL_HEIGHT: 50,  // pixels\n        MARGIN_SIZE: 20,  // pixels\n        NUM_STEPS_ACROSS_CANVAS: 30,\n        DEFAULT_BACKGROUND_COLOR: 'white',\n        DEFAULT_BORDER_COLOR: 'darkgreen',\n        TELEPORT_BORDER_COLOR: 'blue',\n        TELEPORT_BACKGROUND_COLOR: '#e2f1fa',  // a light blue\n        FILTERS: {\n            NONE: 'none',\n            PAUSE: 'contrast(1.4) sepia(1)',\n            ENDGAME: 'grayscale(0.8) blur(0.5px)',\n        },\n    },\n\n    SNAKE: {\n        INITIAL_LENGTH: 5,\n        DEFAULT_COLOR: 'lightgreen',\n        DEFAULT_BORDER_COLOR: 'darkgreen',\n        PHASE_BORDER_COLOR: 'violet',\n    },\n\n    ITEM: {\n        FOOD_COLOR: 'red',\n        FOOD_BORDER_COLOR: 'darkred',\n        PHASE_COLOR: 'orchid',\n        PHASE_BORDER_COLOR: 'violet',\n        TELEPORT_COLOR: 'blue',\n        TELEPORT_BORDER_COLOR: 'darkblue',\n        PHASE_SCORE_THRESHOLD: 150,\n        TELEPORT_SCORE_THRESHOLD: 50,\n        BASE_PHASE_PROBABILITY: 0.1,\n        BASE_TELEPORT_PROBABILITY: 0.1,\n        BASE_VOLATILE_FOOD_PROBABILITY: 0.01,\n    },\n\n    GAME: {\n        SCORE_INCREMENT: 10,\n        SCORE_THRESHOLD_FOR_VOLATILE_FOOD: 100,\n        SPEED_MS__ARROW: 100,\n        SPEED_MS__MOTION: 125,          // slow down game since harder with motion controls\n    },\n\n    INPUT: {\n        SWIPE_SENSITIVITY: 10,          // delta of pixels needed to consider touch mvmt a 'swipe'\n        MOTION_SENSITIVITY: 15,         // degree of motion needed to consider a device mvmt as intentional\n        MOTION_THROTTLE_TIME_MS: 100,   // min time between motion control updates to prevent over-sensitivity\n        MOTION_DEADZONE: 2,             // in degrees TODO:\n        DOMINANT_DIRECTION_THRESHOLD: 5,// TODO:\n    },\n\n    CANVAS: {\n        GAME_TEXT_COLOR: 'gray',\n        HIGH_SCORE_TEXT_COLOR: 'goldenrod',\n        PAUSE_BTN_COLOR: 'darkkhaki',\n        EXCLAMATION_BTN_COLOR: 'darkkhaki',\n        GAME_TEXT_FONT_FAMILY: '\"Saira\", serif',\n        GAME_TEXT_FONT_SIZE: 50,\n    },\n\n    STATE: {\n        LOCAL_STORAGE_KEY_HIGH_SCORE: 'highScore',\n        LOCAL_STORAGE_KEY_GAME_SPEED: 'gameSpeed',\n    },\n\n    ERROR: {\n        // ERROR_MESSAGE_DURATION: 5000,\n        MESSAGE_FONT: '20px Arial',\n        MESSAGE_COLOR: 'red',\n        MESSAGE_BACKGROUND: 'rgba(0, 0, 0, 0.7)',\n    },\n};\n","import { GAME_CONFIG } from './config';\n\nconst { BOARD } = GAME_CONFIG;\n\nconst BUTTON_IDS = {\n    MOTION_REQUEST: 'motionRequest',\n    MOTION_INDICATOR_TOGGLE: 'motionIndicatorToggle',\n    CLEAR_HIGH_SCORE: 'clearHighScore'\n};\n\n/**\n * Represents the game board.\n */\nexport class Board {\n    /**\n     * @param {HTMLCanvasElement} canvas - canvas element for the game\n     * @param {HTMLDivElement | null} ctrlPanel - control panel element\n     */\n    constructor(canvas, ctrlPanel) {\n        this._canvas = canvas;\n        this._ctrlPanel = ctrlPanel;\n\n        // 2d drawing context\n        if (!(this.ctx = this._canvas.getContext('2d'))) {\n            throw new Error('2d context not supported or canvas already initialized');\n        }\n\n        this._boardSize = this._calculateBoardSize();\n\n        // handle rendering difference between a standard display vs a HiDPI or Retina display\n        this._ratio = window.devicePixelRatio || 1;\n\n        this._sizeCanvas();\n        this._sizeControlPanel();\n\n        this._width = canvas.width;\n        this._height = canvas.height;\n        this._blockSize = canvas.width / BOARD.NUM_STEPS_ACROSS_CANVAS;\n\n        this._activeFilter = BOARD.FILTERS.NONE;\n        this._color = BOARD.DEFAULT_BACKGROUND_COLOR;\n        this._borderColor = BOARD.DEFAULT_BORDER_COLOR;\n        this._isGlowing = false;\n\n        this.resetFilter();\n\n        // console.log({\n        //     ratio: this._ratio, 'canvas.style.width': canvas.style.width,\n        //     'canvas.style.height': canvas.style.height, 'canvas.width': canvas.width,\n        //     'canvas.height': canvas.height, block_size: this._blockSize\n        // })\n    }\n\n    /**\n     * @returns {HTMLCanvasElement}\n     */\n    get canvas() {\n        return this._canvas;\n    }\n\n    /**\n     * @returns {string}\n     */\n    get color() {\n        return this._color;\n    }\n\n    /**\n     * @returns {string}\n     */\n    get borderColor() {\n        return this._borderColor;\n    }\n\n    /**\n     * @returns {boolean}\n     */\n    get isGlowing() {\n        return this._isGlowing;\n    }\n\n    /**\n     * @returns {string}\n     */\n    get activeFilter() {\n        return this._activeFilter;\n    }\n\n    /**\n     * @returns {number}\n     */\n    get width() {\n        return this._width;\n    }\n\n    /**\n     * @returns {number}\n     */\n    get height() {\n        return this._height;\n    }\n\n    /**\n     * @returns {number}\n     */\n    get blockSize() {\n        return this._blockSize;\n    }\n\n    /**\n     * @returns {number}\n     */\n    get ratio() {\n        return this._ratio;\n    }\n\n    /**\n     * Resets the board filter to default.\n     */\n    resetFilter() {\n        this._activeFilter = BOARD.FILTERS.NONE;\n    }\n\n    /**\n     * Sets the board filter for the end game state.\n     */\n    setEndGameFilter() {\n        this._activeFilter = BOARD.FILTERS.ENDGAME;\n    }\n\n    /**\n     * Sets the board filter for the paused game state.\n     */\n    setPauseGameFilter() {\n        this._activeFilter = BOARD.FILTERS.PAUSE;\n    }\n\n    /**\n     * Enters fullscreen mode.\n     */\n    enterFullScreen() {\n        // switch to full screen\n        this._canvas.requestFullscreen().then(function () {\n            try {\n                // lock portrait orientation when going full screen\n                // @ts-ignore\n                screen.lockOrientationUniversal = screen.lockOrientation ||\n                    // @ts-ignore\n                    screen.mozLockOrientation ||\n                    // @ts-ignore\n                    screen.msLockOrientation;\n                // @ts-ignore\n                screen.lockOrientationUniversal('portrait-primary');\n            } catch (e) {\n                // console.log(e);\n            }\n        });\n    }\n\n    /**\n     * Exits fullscreen mode.\n     */\n    exitFullScreen() {\n        document.exitFullscreen();\n    }\n\n    /**\n     * Creates or retrieves button in control panel that requests motion control permission.\n     * @returns {HTMLButtonElement|null} motion request button, or null if the control panel does not exist\n     */\n    createMotionRequestButton() {\n        return this._createOrGetButton(BUTTON_IDS.MOTION_REQUEST, 'Allow Motion');\n    }\n\n    /**\n     * Retrieves the motion request button.\n     * @returns {HTMLButtonElement|null} motion request button if it exists; otherwise null\n     */\n    getMotionRequestButton() {\n        return this._getButton(BUTTON_IDS.MOTION_REQUEST);\n    }\n\n    /**\n     * Removes the motion request button from the DOM.\n     */\n    removeMotionRequestButton() {\n        const btn = this.getMotionRequestButton();\n        btn?.parentNode?.removeChild(btn);\n    }\n\n    /**\n     * Creates or retrieves button in control panel that toggles the motion indicator UI.\n     * @returns {HTMLButtonElement|null} motion indicator toggle button, or null if the control panel does not exist\n     */\n    createMotionIndicatorToggleButton() {\n        return this._createOrGetButton(BUTTON_IDS.MOTION_INDICATOR_TOGGLE, 'Motion Guide', {\n            style: 'display: none;'\n        });\n    }\n\n    /**\n     * Retrieves the motion indicator toggle button.\n     * @returns {HTMLButtonElement|null} motion indicator toggle button if it exists; otherwise null\n     */\n    getMotionIndicatorToggleButton() {\n        return this._getButton(BUTTON_IDS.MOTION_INDICATOR_TOGGLE);\n    }\n\n    /**\n     * Shows the motion indicator toggle button.\n     * If the button does not exist, this method does nothing.\n     */\n    showMotionIndicatorToggleButton() {\n        const toggleButton = this.getMotionIndicatorToggleButton();\n        if (toggleButton) {\n            toggleButton.classList.remove('hide');\n            toggleButton.classList.add('show');\n        }\n    }\n\n    /**\n     * Hides the motion indicator toggle button.\n     * If the button does not exist, this method does nothing.\n     */\n    hideMotionIndicatorToggleButton() {\n        const toggleButton = this.getMotionIndicatorToggleButton();\n        if (toggleButton) {\n            toggleButton.classList.remove('show');\n            toggleButton.classList.add('hide');\n        }\n    }\n\n    /**\n     * Updates the text of the motion indicator toggle button based on the indicator's visibility.\n     * @param {boolean} isIndicatorVisible - Whether the motion indicator is currently visible.\n     */\n    updateMotionIndicatorToggleButtonTitle(isIndicatorVisible) {\n        const toggleButton = this.getMotionIndicatorToggleButton();\n        if (toggleButton) {\n            toggleButton.title = isIndicatorVisible ? 'Hide Motion Guide' : 'Show Motion Guide';\n        }\n    }\n\n    /**\n     * Creates or retrieves button in control panel that clears the high score.\n     * @returns {HTMLButtonElement|null} clear high score button, or null if the control panel does not exist\n     */\n    createClearHighScoreButton() {\n        return this._createOrGetButton(BUTTON_IDS.CLEAR_HIGH_SCORE, 'Clear High Score');\n    }\n\n    /**\n     * Retrieves the clear high score button.\n     * @returns {HTMLButtonElement|null} clear high score button if it exists; otherwise null\n     */\n    getClearHighScoreButton() {\n        return this._getButton(BUTTON_IDS.CLEAR_HIGH_SCORE);\n    }\n\n    /**\n     * Sets the glow effect on the board.\n     * @param {boolean} shouldGlow - whether the board should glow\n     */\n    setGlow(shouldGlow) {\n        if (shouldGlow === this.isGlowing) return;\n\n        this._isGlowing = shouldGlow;\n\n        if (shouldGlow) {\n            // note: since canvas border doesn't show in fullscreen mode, we tint the background too\n            this._color = BOARD.TELEPORT_BACKGROUND_COLOR;\n            this._borderColor = BOARD.TELEPORT_BORDER_COLOR;\n        } else {\n            this._color = BOARD.DEFAULT_BACKGROUND_COLOR;\n            this._borderColor = BOARD.DEFAULT_BORDER_COLOR;\n        }\n\n        // console.log(`[board] shouldGlow: ${shouldGlow}; borderColor: ${this.borderColor}; isGlowing: ${this.isGlowing}`);\n    }\n\n    /**\n     * Checks if the game needs permission for motion control.\n     * @returns {boolean} true if permission is needed; false otherwise\n     */\n    needsPermission() {\n        const requestButton = this.getMotionRequestButton();\n        if (!requestButton) return false;\n\n        // try modern Element.checkVisibility() first\n        if (typeof requestButton.checkVisibility === 'function') {\n            return requestButton.checkVisibility();\n        }\n\n        // fallback to checking computed style\n        const computedStyle = window.getComputedStyle(requestButton);\n        return computedStyle.display !== 'none' && computedStyle.visibility !== 'hidden';\n    }\n\n    /**\n     * Calculates the size of the game board.\n     * @returns {number} calculated board size\n     * @private\n     */\n    _calculateBoardSize() {\n        // calculate a square board size based on window dimensions and total # of steps across the canvas\n        const availableSpace = Math.min(window.innerWidth, window.innerHeight) - BOARD.CTRL_PANEL_HEIGHT;\n        const gridBlockSize = availableSpace / BOARD.NUM_STEPS_ACROSS_CANVAS;  // find closest number divisible by steps\n        const boardSize = Math.floor(gridBlockSize) * BOARD.NUM_STEPS_ACROSS_CANVAS - BOARD.MARGIN_SIZE;\n\n        // TODO: could implement like below instead - if willing to implement resizing\n        // const maxWidth = window.innerWidth - MARGIN_SIZE;\n        // const maxHeight = window.innerHeight - CTRL_PANEL_HEIGHT - MARGIN_SIZE;\n        // const boardSize = Math.min(maxWidth, maxHeight);\n\n        return boardSize;\n    }\n\n    /**\n     * Sets the size of the canvas.\n     * @private\n     */\n    _sizeCanvas() {\n        this._canvas.style.width = this._boardSize + 'px';\n        this._canvas.style.height = this._boardSize + 'px';\n        this._canvas.width = this._boardSize * this._ratio;\n        this._canvas.height = this._canvas.width;\n    }\n\n    /**\n     * Sets the size of the control panel.\n     * @private\n     */\n    _sizeControlPanel() {\n        if (!this._ctrlPanel) return;\n        this._ctrlPanel.style.width = this._boardSize + 'px';\n        this._ctrlPanel.style.height = BOARD.CTRL_PANEL_HEIGHT + 'px';\n    }\n\n    /**\n     * Creates or retrieves a button in the control panel.\n     * @param {string} id - ID of the button\n     * @param {string} text - text content of the button\n     * @param {Object} [options={}] - additional options for the button\n     * @param {string} [options.style] - inline CSS styles for the button\n     * @returns {HTMLButtonElement|null} created or existing button, or null if the control panel doesn't exist\n     * @private\n     */\n    _createOrGetButton(id, text, options = {}) {\n        if (!this._ctrlPanel) return null;\n\n        let existingBtn = this._getButton(id);\n        if (existingBtn) return existingBtn;\n\n        let btn = document.createElement('button');\n        btn.type = 'button';\n        btn.id = id;\n        btn.textContent = text;\n        if (options.style) btn.style.cssText = options.style;\n        this._ctrlPanel.appendChild(btn);\n        return btn;\n    }\n\n    /**\n     * Retrieves a button from the DOM by its ID.\n     * @param {string} id - ID of the button to retrieve\n     * @returns {HTMLButtonElement|null} button if it exists and is a button element; otherwise null\n     * @private\n     */\n    _getButton(id) {\n        const element = document.getElementById(id);\n        return element instanceof HTMLButtonElement ? element : null;\n    }\n}\n","import { GAME_CONFIG } from './config';\n\nconst { ERROR } = GAME_CONFIG;\n\n/**\n * Displays an error message on the screen.\n * @param {string} message - error message to display\n * @param {HTMLCanvasElement | HTMLElement | null} canvas - game canvas (if available)\n */\nexport function displayErrorMessage(message, canvas = null) {\n    if (canvas && canvas instanceof HTMLCanvasElement) {\n        displayErrorOnCanvas(message, canvas);\n    } else {\n        displayErrorInDOM(message);\n    }\n}\n\n/**\n * Displays an error message on the canvas.\n * @param {string} message - error message to display\n * @param {HTMLCanvasElement} canvas - game canvas\n * @private\n */\nfunction displayErrorOnCanvas(message, canvas) {\n    const ctx = canvas.getContext('2d');\n    if (!ctx) {\n        console.error('unable to get 2D context from canvas');\n        displayErrorInDOM(message);\n        return;\n    }\n\n    // save the current canvas state\n    ctx.save();\n\n    // set up the error message style\n    ctx.font = ERROR.MESSAGE_FONT;\n    ctx.fillStyle = ERROR.MESSAGE_BACKGROUND;\n\n    // calculate message width and position\n    const messageWidth = ctx.measureText(message).width + 20; // Add some padding\n    const messageHeight = 30;\n    const messageX = (canvas.width - messageWidth) / 2;\n    const messageY = canvas.height / 2 - messageHeight / 2;\n\n    // draw the background\n    ctx.fillRect(messageX, messageY, messageWidth, messageHeight);\n\n    // draw the error message\n    ctx.fillStyle = ERROR.MESSAGE_COLOR;\n    ctx.textAlign = 'center';\n    ctx.textBaseline = 'middle';\n    ctx.fillText(message, canvas.width / 2, canvas.height / 2);\n\n    // restore the canvas state\n    ctx.restore();\n\n    // remove the error message after a set duration\n    // setTimeout(() => {\n    //     ctx.clearRect(0, 0, canvas.width, canvas.height);\n    //     // note: not redrawing the game here as we might not have a valid game state\n    // }, ERROR_MESSAGE_DURATION);\n}\n\n/**\n * Displays an error message in the DOM.\n * @param {string} message - error message to display\n * @private\n */\nfunction displayErrorInDOM(message) {\n    const errorDiv = document.createElement('div');\n    errorDiv.style.position = 'fixed';\n    errorDiv.style.top = '50%';\n    errorDiv.style.left = '50%';\n    errorDiv.style.transform = 'translate(-50%, -50%)';\n    errorDiv.style.backgroundColor = ERROR.MESSAGE_BACKGROUND;\n    errorDiv.style.color = ERROR.MESSAGE_COLOR;\n    errorDiv.style.padding = '15px';\n    errorDiv.style.borderRadius = '5px';\n    errorDiv.style.zIndex = '1000';\n\n    // preserve line breaks in multi-line messages\n    errorDiv.style.whiteSpace = 'pre-wrap';\n\n    // for long messages, add a max-width and use word-wrapping\n    errorDiv.style.maxWidth = '80%';\n    errorDiv.style.overflowWrap = 'break-word';\n\n    errorDiv.textContent = message;\n\n    document.body.appendChild(errorDiv);\n\n    // setTimeout(() => {\n    //     document.body.removeChild(errorDiv);\n    // }, ERROR_MESSAGE_DURATION);\n}\n","import { GAME_CONFIG } from './config';\n\nconst { ITEM } = GAME_CONFIG;\n\nexport const PHASE_CLASSNAME = 'Phase';\nexport const TELEPORT_CLASSNAME = 'Teleport';\n\n/**\n * Represents an item that can be consumed by snek in the game.\n */\nexport class Item {\n    /**\n     * @param {import('./board').Board} board - game board\n     * @param {import('./snake').Snake} snake - snek object\n     */\n    constructor(board, snake) {\n        this._x = Number.MIN_SAFE_INTEGER, this._y = Number.MIN_SAFE_INTEGER;\n        this._generate(board, snake);\n    }\n\n    /**\n     * Gets the x-coordinate of the item.\n     * @returns {number} x-coordinate\n     */\n    get x() {\n        return this._x;\n    }\n\n    /**\n     * Gets the y-coordinate of the item.\n     * @returns {number} y-coordinate\n     */\n    get y() {\n        return this._y;\n    }\n\n    /**\n     * Gets the type of the item.\n     * @returns {string} item type\n     */\n    get type() { return 'UNKNOWN_ITEM' }\n\n    /**\n     * Gets the fill color of the item.\n     * @returns {string} fill color\n     */\n    get fillColor() { return '' }\n\n    /**\n     * Gets the border color of the item.\n     * @returns {string} border color\n     */\n    get borderColor() { return '' }\n\n    /**\n     * Generates a new position for the item.\n     * @param {import('./board').Board} board - game board\n     * @param {import('./snake').Snake} snake - snek object\n     * @private\n     */\n    _generate(board, snake) {\n        this._x = this._randomBlock(0, board.width - board.blockSize, board.blockSize);\n        this._y = this._randomBlock(0, board.height - board.blockSize, board.blockSize);\n\n        snake.forEachSegment((/** @type {{ x: number; y: number; }} @returns {void} */ snakeSegment) => {\n            const itemIsOnSnake = snakeSegment.x == this.x && snakeSegment.y == this.y\n            if (itemIsOnSnake) this._generate(board, snake);\n        });\n    }\n\n    /**\n     * Generates a random block position.\n     * @param {number} min - minimum value\n     * @param {number} max - maximum value\n     * @param {number} blockSize - size of each block\n     * @returns {number} random block position\n     * @private\n     */\n    _randomBlock(min, max, blockSize) {\n        // note: round to snap item placement to grid, as defined by blockSize\n        return Math.round((Math.random() * (max-min) + min) / blockSize) * blockSize;\n    }\n}\n\n/**\n * Represents a food item in the game.\n * Food is the basic item that snek consumes to grow and increase the player's score.\n * @extends Item\n */\nexport class Food extends Item {\n\n    /**\n     * Gets the food type.\n     * @returns {string} food type\n     */\n    get type() { return 'FOOD' }\n\n    /**\n     * Gets the fill color of the food.\n     * @returns {string} fill color\n     */\n    get fillColor() { return ITEM.FOOD_COLOR }\n\n    /**\n     * Gets the border color of the food.\n     * @returns {string} border color\n     */\n    get borderColor() { return ITEM.FOOD_BORDER_COLOR }\n}\n\n/**\n * Represents a teleport item in the game.\n * Teleport is a power-up that allows snek to pass through the walls of the game board.\n * When consumed, it gives snek the ability to \"wrap around\" the game board once.\n * @extends Item\n */\nexport class Teleport extends Item {\n\n    /**\n     * Gets the teleport type.\n     * @returns {string} teleport type\n     */\n    get type() { return 'TELEPORT' }\n\n    /**\n     * Gets the fill color of the teleport item.\n     * @returns {string} fill color\n     */\n    get fillColor() { return ITEM.TELEPORT_COLOR }\n\n    /**\n     * Gets the border color of the teleport item.\n     * @returns {string} border color\n     */\n    get borderColor() { return ITEM.TELEPORT_BORDER_COLOR }\n}\n\n/**\n * Represents a phase item in the game.\n * Phase is a power-up that allows snek the ability to pass through its own body once.\n * @extends Item\n */\nexport class Phase extends Item {\n\n    /**\n     * Gets the phase type.\n     * @returns {string} phase type\n     */\n    get type() { return 'PHASE' }\n\n    /**\n     * Gets the fill color of the phase item.\n     * @returns {string} fill color\n     */\n    get fillColor() { return ITEM.PHASE_COLOR }\n\n    /**\n     * Gets the border color of the phase item.\n     * @returns {string} border color\n     */\n    get borderColor() { return ITEM.PHASE_BORDER_COLOR }\n}\n\nconst ITEM_TYPES = {\n    none: null,\n    food: Food,\n    teleport: Teleport,\n    phase: Phase\n};\n\n/**\n * Options for item selection.\n * @typedef {Object} ItemSelectionOptions\n * @property {boolean} [alwaysReturnItem=false] - If true, always returns an item (never null)\n * @property {boolean} [reducePowerUpProbability=false] - If true, reduces the probability of power-ups\n */\n\n/**\n * Randomizes the selection of an item type based on game conditions.\n * @param {number} score - current game score\n * @param {{ [x: string]: boolean; }} powerUps - available power-ups and whether eqipped\n * @param {ItemSelectionOptions} [options={}] - options for item selection\n * @returns {(new (board: import('./board').Board, item: import('./snake').Snake) => Item)} selected item class or null\n */\nexport function selectRandomItem(score, powerUps, options = {}) {\n    const { alwaysReturnItem = false, reducePowerUpProbability = false } = options;\n\n    const itemChances = calculateItemProbabilities(score, powerUps, alwaysReturnItem, reducePowerUpProbability);\n\n    // console.log(itemChances);\n\n    const selectedItemType = pickItem(itemChances);\n    return ITEM_TYPES[selectedItemType];\n}\n\n/**\n * Picks an item based on a weighted random selection algorithm.\n * @param {{ [x: string]: any; }} chances - chances for each item\n * @returns {string} selected item key\n */\nfunction pickItem(chances) {\n    const random = Math.random();  // random value to use for selection\n    let cumulativeProbability = 0;\n\n    for (const [item, probability] of Object.entries(chances)) {\n        cumulativeProbability += probability;\n        if (random <= cumulativeProbability) {\n            return item;\n        }\n    }\n\n    // this should never happen if probabilities sum to 1\n    throw new Error('item selection failed');\n}\n\n/**\n * Calculates probability of generation for each item type.\n * Provides ability to balance the game by making power-ups less frequent in certain situations.\n * @param {number} score - current game score\n * @param {{ [x: string]: boolean }} powerUps - current power-ups\n * @param {boolean} alwaysReturnItem - whether to always return an item\n * @param {boolean} reducePowerUpProbability - whether to reduce the probability of power-ups\n * @returns {{ [x: string]: number }} probabilities for each item type\n */\nfunction calculateItemProbabilities(score, powerUps, alwaysReturnItem, reducePowerUpProbability) {\n    // note: a power-up always drops AT its score threshold; afterwards drops get random\n    const teleportProb = calculateTeleportProbability(score, powerUps, alwaysReturnItem, reducePowerUpProbability);\n    const phaseProb = calculatePhaseProbability(score, powerUps, alwaysReturnItem, reducePowerUpProbability);\n\n    let foodProb, noItemProb;\n    if (alwaysReturnItem) {\n        foodProb = 1 - teleportProb - phaseProb;\n        noItemProb = 0;\n    } else {\n        foodProb = ITEM.BASE_VOLATILE_FOOD_PROBABILITY;\n        noItemProb = 1 - teleportProb - phaseProb - foodProb;\n    }\n\n    const probabilities = {\n        none: noItemProb,\n        food: foodProb,\n        teleport: teleportProb,\n        phase: phaseProb,\n    };\n\n    const totalProb = Object.values(probabilities).reduce((sum, prob) => sum + prob, 0);\n    if (Math.abs(totalProb - 1) > 1e-10) {  // allow for small floating-point errors\n        throw new Error(`Item probabilities must sum to 1. Current sum: ${totalProb}`);\n    }\n\n    return probabilities;\n}\n\n/**\n * Calculates the probability of generating a Teleport item.\n * @param {number} score - current game score\n * @param {{ [x: string]: boolean }} powerUps - current power-ups\n * @param {boolean} alwaysReturnItem - whether to always return an item\n * @param {boolean} reducePowerUpProbability - whether to reduce the probability of power-ups\n * @returns {number} probability of generating a Teleport item\n */\nfunction calculateTeleportProbability(score, powerUps, alwaysReturnItem, reducePowerUpProbability) {\n    if (score === ITEM.TELEPORT_SCORE_THRESHOLD && alwaysReturnItem) return 1;\n    if (score > ITEM.TELEPORT_SCORE_THRESHOLD && !powerUps[TELEPORT_CLASSNAME]) {\n        return reducePowerUpProbability ? ITEM.BASE_TELEPORT_PROBABILITY / 10 : ITEM.BASE_TELEPORT_PROBABILITY;\n    }\n    return 0;\n}\n\n/**\n * Calculates the probability of generating a Phase item.\n * @param {number} score - current game score\n * @param {{ [x: string]: boolean }} powerUps - current power-ups\n * @param {boolean} alwaysReturnItem - whether to always return an item\n * @param {boolean} reducePowerUpProbability - whether to reduce the probability of power-ups\n * @returns {number} probability of generating a Phase item\n */\nfunction calculatePhaseProbability(score, powerUps, alwaysReturnItem, reducePowerUpProbability) {\n    if (score === ITEM.PHASE_SCORE_THRESHOLD && alwaysReturnItem) return 1;\n    if (score > ITEM.PHASE_SCORE_THRESHOLD && !powerUps[PHASE_CLASSNAME]) {\n        return reducePowerUpProbability ? ITEM.BASE_PHASE_PROBABILITY / 10 : ITEM.BASE_PHASE_PROBABILITY;\n    }\n    return 0;\n}\n","export const DIRECTION_LEFT = 'left';\nexport const DIRECTION_RIGHT = 'right';\nexport const DIRECTION_UP = 'up';\nexport const DIRECTION_DOWN = 'down';\n\n/**\n * @typedef {Object} Direction\n * @property {number} dx - change in x direction\n * @property {number} dy - change in y direction\n */\n\n/**\n * Object mapping direction strings to their corresponding Direction objects.\n * @type {Object.<string, Direction>}\n */\nexport const DIRECTIONS = {\n    [DIRECTION_LEFT]:  { dx: -1, dy: 0 },\n    [DIRECTION_RIGHT]: { dx: 1,  dy: 0 },\n    [DIRECTION_UP]:    { dx: 0,  dy: -1 },\n    [DIRECTION_DOWN]:  { dx: 0,  dy: 1 },\n};\n\n/**\n * Gets the Direction object for a given direction string.\n * @param {string} direction - direction string\n * @returns {Direction | null} Direction object or null if not found\n */\nexport function getDirection(direction) {\n    return DIRECTIONS[direction.toLowerCase()] || null;\n}\n\n/**\n * Checks if two directions are opposite to each other.\n * @param {Direction} dir1 - first direction\n * @param {Direction} dir2 - second direction\n * @returns {boolean} true if the directions are opposite; false otherwise\n */\nexport function isOppositeDirection(dir1, dir2) {\n    return dir1.dx === -dir2.dx && dir1.dy === -dir2.dy;\n}\n\n/**\n * Normalizes a direction vector to have a magnitude of 1.\n * @param {number} dx - x component of the direction\n * @param {number} dy - y component of the direction\n * @returns {Direction} normalized direction\n */\nexport function normalizeDirection(dx, dy) {\n    const magnitude = Math.max(Math.abs(dx), Math.abs(dy));\n    if (magnitude === 0) {\n        return { dx: 0, dy: 0 };\n    }\n    return { dx: dx / magnitude, dy: dy / magnitude };\n}\n","import { GAME_CONFIG } from './config';\nimport { DIRECTION_DOWN, DIRECTION_LEFT, DIRECTION_RIGHT, DIRECTION_UP } from './direction';\n\nconst { INPUT } = GAME_CONFIG;\n\n/**\n * Represents a visual indicator for motion controls.\n */\nexport class MotionControlIndicator {\n\n    /**\n     * @param {HTMLDivElement} container - container element to render the indicator in\n     * @param {Object} [options={}] - configuration options for the indicator\n     * @param {boolean} [options.showInfo=true] - whether to show additional information\n     * @param {string} [options.position='inline'] - position of the indicator ('inline' or 'corner')\n     */\n    constructor(container, options = {}) {\n        this.container = container;\n        this.options = {\n            showInfo: true,\n            position: 'inline',\n            ...options\n        };\n        this._create();\n    }\n\n    /**\n     * Updates the motion control indicator based on the current orientation and direction.\n     * @param {{ beta: number, gamma: number }} orientation - current device orientation\n     * @param {string|null} direction - current direction of movement (UP, DOWN, LEFT, RIGHT, or null)\n     * TODO: sensitivity\n     */\n    update(orientation, direction, sensitivity) {\n        const { beta, gamma } = orientation;\n        const maxTilt = 30;\n        const tiltX = Math.min(Math.max(gamma, -maxTilt), maxTilt) / maxTilt;\n        const tiltY = Math.min(Math.max(beta, -maxTilt), maxTilt) / maxTilt;\n\n        const dotPx = this.options.position === 'corner' ? 40 : 60;\n        if (this.dot instanceof HTMLDivElement) {\n            this.dot.style.transform = `translate(${tiltX * dotPx}px, ${tiltY * dotPx}px)`;\n        }\n\n        if (this.arrows) {\n            this.arrows.forEach(arrow => arrow.classList.remove('active'));\n        }\n        if (direction) {\n            const activeArrow = this.container.querySelector(`.arrow.${direction.toLowerCase()}`);\n            if (activeArrow instanceof HTMLDivElement) {\n                activeArrow.classList.add('active')\n            }\n\n            if (this.options.showInfo && this.directionValue instanceof HTMLSpanElement) {\n                if (this.directionValue.textContent !== direction) {\n                    this.directionValue.classList.add('highlight');\n                    this.directionValue.textContent = direction;\n                    setTimeout(() => {\n                        if (this.directionValue instanceof HTMLSpanElement) {\n                            this.directionValue.classList.remove('highlight');\n                        }\n                    }, 300);\n                }\n            }\n        }\n\n        if (this.options.showInfo) {\n            if (this.betaValue instanceof HTMLSpanElement) {\n                this.betaValue.textContent = beta.toFixed(2);\n            }\n            if (this.gammaValue instanceof HTMLSpanElement) {\n                this.gammaValue.textContent = gamma.toFixed(2);\n            }\n            if (this.sensitivityValue instanceof HTMLSpanElement) {\n                this.sensitivityValue.textContent = sensitivity.toFixed(2);\n            }\n        }\n    }\n\n    /**\n     * Makes the motion control indicator visible, if it exists.\n     */\n    show() {\n        if (this.container) {\n            this.container.style.display = 'block';\n        }\n    }\n\n    /**\n     * Hides the motion control indicator, if it exists.\n     */\n    hide() {\n        if (this.container) {\n            this.container.style.display = 'none';\n        }\n    }\n\n    /**\n     * Creates the DOM elements for the motion control indicator.\n     * @private\n     */\n    _create() {\n        this.container.innerHTML = `\n            <div class=\"motion-indicator ${this.options.position}\">\n                <div class=\"tilt-indicator ${this.options.position}\">\n                    <div class=\"dot\"></div>\n                    <div class=\"arrow up ${this.options.position}\">\\u25B2\\uFE0E</div>\n                    <div class=\"arrow down ${this.options.position}\">\\u25BC\\uFE0E</div>\n                    <div class=\"arrow left ${this.options.position}\">\\u25C0\\uFE0E</div>\n                    <div class=\"arrow right ${this.options.position}\">\\u25B6\\uFE0E</div>\n                </div>\n                ${this.options.showInfo ? `\n                <div class=\"info\">\n                    <p>Direction: <span class=\"direction-value\">None</span></p>\n                    <p>Sensitivity: <span class=\"sensitivity-value\">1.00</span></p>\n                    <p>Beta: <span class=\"beta-value\">0.00</span>°</p>\n                    <p>Gamma: <span class=\"gamma-value\">0.00</span>°</p>\n                </div>\n                ` : ''}\n            </div>\n        `;\n\n        this.dot = this.container.querySelector('.dot');\n        this.arrows = this.container.querySelectorAll('.arrow');\n        this.directionValue = this.container.querySelector('.direction-value');\n        this.sensitivityValue = this.container.querySelector('.sensitivity-value');\n        this.betaValue = this.container.querySelector('.beta-value');\n        this.gammaValue = this.container.querySelector('.gamma-value');\n\n        this._addStyles();\n    }\n\n    /**\n     * Adds the necessary styles for the motion control indicator.\n     * @private\n     */\n    _addStyles() {\n        const style = document.createElement('style');\n        style.textContent = `\n            .motion-indicator {\n                display: flex;\n                justify-content: space-between;\n                align-items: center;\n            }\n            .motion-indicator.corner {\n                position: fixed;\n                bottom: 20px;\n                right: 20px;\n                background: white;\n                padding: 10px;\n                border-radius: 10px;\n                box-shadow: 0 0 10px rgba(0,0,0,0.1);\n            }\n            .tilt-indicator {\n                width: 150px;\n                height: 150px;\n                border: 2px solid #ccc;\n                border-radius: 10px;\n                position: relative;\n                overflow: hidden;\n            }\n            .tilt-indicator.corner {\n                width: 100px;\n                height: 100px;\n            }\n            .dot {\n                width: 20px;\n                height: 20px;\n                background: blue;\n                border-radius: 50%;\n                position: absolute;\n                top: 50%;\n                left: 50%;\n                transform: translate(-50%, -50%);\n                transition: transform 0.1s ease;\n            }\n            .arrow {\n                position: absolute;\n                color: #ccc;\n                font-size: 24px;\n                transition: color 0.3s ease;\n            }\n            .arrow.up { top: 10px; left: 50%; transform: translateX(-50%); }\n            .arrow.down { bottom: 10px; left: 50%; transform: translateX(-50%); }\n            .arrow.left { left: 10px; top: 50%; transform: translateY(-50%); }\n            .arrow.right { right: 10px; top: 50%; transform: translateY(-50%); }\n            .arrow.active { color: green; }\n            .arrow.up.corner { top: 5px; }\n            .arrow.down.corner { bottom: 5px; }\n            .arrow.left.corner { left: 5px; }\n            .arrow.right.corner { right: 5px; }\n            .info {\n                text-align: left;\n                margin-left: 20px;\n            }\n            .info p {\n                margin: 5px 0;\n            }\n            .direction-value {\n                display: inline-block;\n                padding: 2px 8px;\n                border-radius: 4px;\n                transition: background-color 0.3s ease;\n            }\n            .direction-value.highlight {\n                background-color: #ffd700;\n            }\n        `;\n        document.head.appendChild(style);\n    }\n}\n\n/**\n * Calculates the motion control based on the current and last device orientation,\n * as well as the time between updates to prevent overly frequent updates.\n *\n * @param {{ beta: number, gamma: number }} currentOrientation - current device orientation\n * TODO: initialOrientation\n * @param {{ beta: number, gamma: number }} lastOrientation - last device orientation\n * @param {number} currentUpdateTime - timestamp of the current update\n * @param {number} lastUpdateTime - timestamp of the last update\n * TODO: sensitivityMultiplier\n *\n * @returns {string|null} direction - calculated direction (UP, DOWN, LEFT, RIGHT),\n *                        or null if no significant motion or if the update is too soon\n */\nexport function calculateMotionControl(currentOrientation, initialOrientation, lastOrientation, currentUpdateTime, lastUpdateTime, sensitivityMultiplier) {\n    if (!initialOrientation) {\n        return { direction: null, sensitivity: 1 };\n    }\n\n    // ensure we are not updating too frequently\n    if (currentUpdateTime - lastUpdateTime < INPUT.MOTION_THROTTLE_TIME_MS) {\n        return null;\n    }\n\n    // calculate change relative to initial orientation\n    const totalChange = {\n        beta: currentOrientation.beta - initialOrientation.beta,\n        gamma: currentOrientation.gamma - initialOrientation.gamma\n    };\n\n    // calculate change since last update\n    const recentChange = {\n        beta: currentOrientation.beta - lastOrientation.beta,\n        gamma: currentOrientation.gamma - lastOrientation.gamma\n    };\n\n    // update sensitivity based on total change from initial position\n    const magnitudeChange = Math.sqrt(totalChange.beta ** 2 + totalChange.gamma ** 2);\n    const newSensitivityMultiplier = 1 + (magnitudeChange / 45);\n\n    // apply deadzone to recent change\n    const adjustedDeadzone = INPUT.MOTION_DEADZONE / newSensitivityMultiplier;\n    if (Math.abs(recentChange.beta) <= adjustedDeadzone) recentChange.beta = 0;\n    if (Math.abs(recentChange.gamma) <= adjustedDeadzone) recentChange.gamma = 0;\n\n    // determine dominant direction based on recent change\n    const direction = isSignificantMotion(recentChange, sensitivityMultiplier) ? getDirectionFromOrientation(recentChange) : null;\n\n    return {\n        direction,\n        sensitivity: newSensitivityMultiplier\n    };\n}\n\n/**\n * Determines if a change in device orientation is significant enough to trigger a direction change.\n * Filters out small, unintentional device movements so we respond only to deliberate motions.\n * @param {Object} orientationChange - change in device orientation\n * @param {number} orientationChange.beta - change in beta (x-axis rotation) in degrees\n * @param {number} orientationChange.gamma - change in gamma (y-axis rotation) in degrees\n    * @returns {boolean} true if the motion is considered significant; false otherwise\n * TODO: sensitivityMultiplier\n * @private\n */\nfunction isSignificantMotion(orientationChange, sensitivityMultiplier) {\n    const threshold = INPUT.MOTION_SENSITIVITY / sensitivityMultiplier;\n    return Math.abs(orientationChange.beta) > threshold || Math.abs(orientationChange.gamma) > threshold;\n}\n\n/**\n* Determine direction based on orientation change.\n* @param {{ beta: number, gamma: number }} orientationChange - the change in device orientation\n* @returns {string | null} determined direction or null\n* @private\n*/\nfunction getDirectionFromOrientation(orientationChange) {\n    let direction = null;\n\n    // determine dominant direction based on recent change\n    const absBeta = Math.abs(orientationChange.beta);\n    const absGamma = Math.abs(orientationChange.gamma);\n\n    if (absBeta > absGamma && absBeta - absGamma > INPUT.DOMINANT_DIRECTION_THRESHOLD) {\n        direction = orientationChange.beta < 0 ? DIRECTION_UP : DIRECTION_DOWN;\n    } else if (absGamma > absBeta && absGamma - absBeta > INPUT.DOMINANT_DIRECTION_THRESHOLD) {\n        direction = orientationChange.gamma < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;\n    }\n    return direction;\n}\n","import { GAME_CONFIG } from './config';\nimport { DIRECTION_DOWN, DIRECTION_LEFT, DIRECTION_RIGHT, DIRECTION_UP, getDirection, isOppositeDirection, normalizeDirection } from './direction';\nimport { PHASE_CLASSNAME, Phase, TELEPORT_CLASSNAME, Teleport } from './item';\n\nconst { SNAKE } = GAME_CONFIG;\n\n/**\n * Represents snek in the game.\n */\nexport class Snake {\n\n    /**\n     * @param {number} boardWidth - width of the game board\n     * @param {number} boardHeight - height of the game board\n     * @param {number} blockSize - size of each block on the board\n     */\n    constructor(boardWidth, boardHeight, blockSize) {\n        this._blockSize = blockSize;\n\n        // calculate initial position (center of the board)\n        const centerX = Math.floor(boardWidth / (2 * blockSize)) * blockSize;\n        const centerY = Math.floor(boardHeight / (2 * blockSize)) * blockSize;\n\n        this._body = this._createBody(centerX, centerY, SNAKE.INITIAL_LENGTH);\n\n        // set initial velocity\n        this._dx = this._dxAtPause = blockSize;\n        this._dy = this._dyAtPause = 0;\n        this._isChangingDirection = false;\n\n        // set initial appearance\n        this._color = SNAKE.DEFAULT_COLOR;\n        this._borderColor = SNAKE.DEFAULT_BORDER_COLOR;\n        this._isGlowing = false;\n\n        this.powerUps = { [TELEPORT_CLASSNAME]: false, [PHASE_CLASSNAME]: false };\n\n        this._directionMap = new Map([\n            [`${blockSize},0`, DIRECTION_RIGHT],\n            [`${-blockSize},0`, DIRECTION_LEFT],\n            [`0,${-blockSize}`, DIRECTION_UP],\n            [`0,${blockSize}`, DIRECTION_DOWN]\n        ]);\n    }\n\n    /**\n     * Creates the body of snek.\n     * @param {number} centerX - x-coordinate of the center of the board\n     * @param {number} centerY - y-coordinate of the center of the board\n     * @param {number} length - number of parts composing snek body\n     * @returns {{ x: number; y: number; }[]} created snek body\n     * @private\n     */\n    _createBody(centerX, centerY, length) {\n        const body = [];\n        for (let i = 0; i < length; i++) {\n            body.push({\n                x: centerX - i * this._blockSize,\n                y: centerY\n            });\n        }\n        return body;\n    }\n\n    /**\n     * Gets snek's fill color.\n     * @returns {string} fill color\n     */\n    get color() {\n        return this._color;\n    }\n\n    /**\n     * Gets snek's border color.\n     * @returns {string} border color\n     */\n    get borderColor() {\n        return this._borderColor;\n    }\n\n    /**\n     * Gets whether snek is glowing.\n     * @returns {boolean} true if snek is glowing; false otherwise\n     */\n    get isGlowing() {\n        return this._isGlowing;\n    }\n\n    /**\n     * Gets the position of snek's head.\n     * @returns {{ x: number; y: number }} head position\n     */\n    getHeadPosition() {\n        return { ...this._body[0] };\n    }\n\n    /**\n     * Gets the current direction of snek.\n     * @returns {string} current direction ('left', 'right', 'up', or 'down')\n     */\n    getCurrentDirection() {\n        const key = `${this._dx},${this._dy}`;\n        return this._directionMap.get(key) || 'unknown';\n    }\n\n    /**\n     * Moves snek in its current direction.\n     * @param {boolean} growing whether snek should grow\n     */\n    move(growing = false) {\n        this._advanceHead();\n        if (!growing) {\n            this._advanceTail();\n        }\n    }\n\n    /**\n     * Advances snek's head.\n     */\n    _advanceHead() {\n        // note: round to snap snek movement to grid, as defined by blockSize\n        const head = {\n            x: Math.round((this.getHeadPosition().x + this._dx) / this._blockSize) * this._blockSize,\n            y: Math.round((this.getHeadPosition().y + this._dy) / this._blockSize) * this._blockSize\n        };\n        this._body.unshift(head);\n\n        this._isChangingDirection = false;\n\n        // TODO: add to control panel\n        // console.log(`HEAD: ${head.x}, ${head.y}`);\n    }\n\n    /**\n     * Advances snek's tail (removes the last segment).\n     */\n    _advanceTail() {\n        this._body.pop();\n    }\n\n    /**\n     * Teleports snek's head to a new position.\n     * Useful for unit testing.\n     * @param {{ x: number; y: number }} newPosition new position for the head\n     */\n    teleportHead(newPosition) {\n        this._body[0] = { ...newPosition };\n    }\n\n    /**\n     * Executes a callback for each segment of snek's body.\n     * @param {(segment: { x: number; y: number }, index: number) => void} callback\n     */\n    forEachSegment(callback) {\n        this._body.forEach((segment, index) => callback({ ...segment }, index));\n    }\n\n    /**\n     * Pauses snek's movement.\n     */\n    pause() {\n        // save velocity at pause\n        this._dxAtPause = this._dx;\n        this._dyAtPause = this._dy;\n        // set velocity to 0\n        this._dx = this._dy = 0;\n    }\n\n    /**\n     * Resumes snek's movement after a pause.\n     */\n    unpause() {\n        // set velocity to state before pause\n        this._dx = this._dxAtPause;\n        this._dy = this._dyAtPause;\n    }\n\n    /**\n     * Checks if snek has eaten an item.\n     * @param {import('./item').Item} item - item to check\n     * @returns {boolean} true if snek has eaten the item; false otherwise\n     */\n    didEat(item) {\n        let head = this.getHeadPosition();\n        return head.x === item.x && head.y === item.y;\n    }\n\n    /**\n     * Equips snek with a power-up\n     * @param {import('./item').Item} item - power-up item to equip\n     */\n    equip(item) {\n        if (item instanceof Teleport) this.powerUps[TELEPORT_CLASSNAME] = true;\n        if (item instanceof Phase) {\n            this.powerUps[PHASE_CLASSNAME] = true;\n            this.setGlow(true);\n        }\n    }\n\n    /**\n     * Sets the glow effect on snek.\n     * @param {boolean} shouldGlow - whether snek should glow\n     */\n    setGlow(shouldGlow) {\n        if (shouldGlow === this.isGlowing) return;\n\n        this._isGlowing = shouldGlow;\n\n        this._borderColor = shouldGlow ? SNAKE.PHASE_BORDER_COLOR : SNAKE.DEFAULT_BORDER_COLOR;\n\n        // console.log(`[snek] shouldGlow: ${shouldGlow}; borderColor: ${this.borderColor}; isGlowing: ${this.isGlowing}`);\n    }\n\n    /**\n     * Checks if snek has collided with itself or the board boundaries.\n     * @param {number} boardWidth - width of the game board\n     * @param {number} boardHeight - height of the game board.\n     * @param {number} blockSize - size of each block on the board\n     * @returns {boolean} true if snek has collided; false otherwise\n     */\n    didCollide(boardWidth, boardHeight, blockSize) {\n        let head = this.getHeadPosition();\n\n        // loop starts at index 4 because it is impossible for the first three parts to touch each other\n        const collidesWithSelf = this._body.slice(4).some(segment => segment.x === head.x && segment.y === head.y);\n        if (collidesWithSelf) {\n            if (this.powerUps[PHASE_CLASSNAME]) {\n                // if phase powerup is equipped, decrement, ignore collision, and continue game\n                this.powerUps[PHASE_CLASSNAME] = false;\n                this.setGlow(false);\n\n                console.log('snek phased!');\n                return false;\n            }\n            return true;\n        }\n\n        // check for collisions with walls\n        const hitLeftWall = head.x < 0;\n        const hitRightWall = head.x + blockSize > boardWidth;\n        const hitTopWall = head.y < 0;\n        const hitBottomWall = head.y + blockSize > boardHeight;\n\n        const hitWall = hitLeftWall || hitRightWall || hitTopWall || hitBottomWall;\n\n        if (!hitWall) { return false; }\n\n        // if teleport power is equipped, decrement, teleport, and continue game\n        if (this.powerUps[TELEPORT_CLASSNAME]) {\n            this.powerUps[TELEPORT_CLASSNAME] = false;\n\n            // teleport to opposite side of the board\n            if (hitLeftWall) {\n                this.teleportHead({x: boardWidth - blockSize, y: head.y});\n            } else if (hitRightWall) {\n                this.teleportHead({x: 0, y: head.y});\n            } else if (hitTopWall) {\n                this.teleportHead({x: head.x, y: boardHeight - blockSize});\n            } else if (hitBottomWall) {\n                this.teleportHead({x: head.x, y: 0});\n            }\n\n            console.log('snek teleported!');\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * Changes the direction of snek.\n     * @param {string} direction - new direction\n     * @returns {boolean} true if snek direction was changed; false otherwise\n     */\n    changeDirection(direction) {\n        // prevent changing direction multiple times before the next move\n        if (this._isChangingDirection) return false;\n\n        const newDirection = getDirection(direction);\n        if (!newDirection) return false;\n\n        const currentDirection = this._getCurrentDirection();\n        // prevent snek from moving back on itself\n        if (isOppositeDirection(currentDirection, newDirection)) return false;\n\n        this._setNewDirection(newDirection);\n        return true;\n    }\n\n    /**\n     * Gets the current direction of snek.\n     * @returns {import('./direction').Direction} current direction\n     * @private\n     */\n    _getCurrentDirection() {\n        // normalize the current velocity to get direction\n        return normalizeDirection(this._dx, this._dy);\n    }\n\n    /**\n     * Sets a new direction for snek.\n     * @param {import('./direction').Direction} direction - new direction\n     * @private\n     */\n    _setNewDirection(direction) {\n        this._isChangingDirection = true;\n        this._dx = direction.dx * this._blockSize;\n        this._dy = direction.dy * this._blockSize;\n    }\n}\n","import { GAME_CONFIG } from '../config';\nimport { DIRECTION_DOWN, DIRECTION_LEFT, DIRECTION_RIGHT, DIRECTION_UP } from '../direction';\nimport { calculateMotionControl } from '../motion';\n\nconst { INPUT } = GAME_CONFIG;\n\nconst SPACE_KEY = 'Space';\nconst LEFT_KEY = 'ArrowLeft';\nconst RIGHT_KEY = 'ArrowRight';\nconst UP_KEY = 'ArrowUp';\nconst DOWN_KEY = 'ArrowDown';\n\n/**\n * global var to persist permission state across game sessions.\n * possible values: 'unknown', 'requesting', 'granted', 'denied'\n * */\nlet motionPermissionState = 'unknown';\n\n/**\n * Handles user input for the game.\n */\nexport class InputHandler {\n    /**\n     * @param {import('./game').Game} game - game instance\n     */\n    constructor(game) {\n        this._game = game;\n\n        this._touchStart = { x: 0, y: 0 };\n        this._touchEnd = { x: 0, y: 0 };\n        this._boundMethods = this._bindMethods();\n\n        // TODO: reset on game pause too\n        this._initialOrientation = null;\n        this._lastOrientation = null;\n        this._lastOrientationUpdateTime = 0;\n        this._sensitivityMultiplier = 1;\n    }\n\n    /**\n     * Creates and returns an object containing all event handler methods bound to the current instance of InputHandler.\n     * Ensures they always have the correct `this` context when called, regardless of how they are invoked.\n     * @returns {Object} object containing bound method references\n     * @private\n     */\n    _bindMethods() {\n        return {\n            handleKeyInput: this._handleKeyInput.bind(this),\n            handleDeviceMovement: this._handleDeviceMovement.bind(this),\n            handleVisibilityChange: this._handleVisibilityChange.bind(this),\n            handlePauseClick: this._handlePauseClick.bind(this),\n            requestDeviceOrientation: this._requestDeviceOrientation.bind(this),\n            enterFullScreen: this._game.board.enterFullScreen.bind(this._game.board),\n            handleTouchStart: this._handleTouchStart.bind(this),\n            handleTouchEnd: this._handleTouchEnd.bind(this),\n            handleRestart: this._handleRestart.bind(this)\n        };\n    }\n\n    /**\n     * Manages all control event listeners for the game.\n     * @param {boolean} shouldAdd - if true, adds the event listeners; if false, removes them.\n     */\n    manageGameControls(shouldAdd) {\n        this._manageKeyboardControls(shouldAdd);\n        this._manageMotionControls(shouldAdd);\n        this._manageTouchControls(shouldAdd);\n        this._manageClickControls(shouldAdd);\n        this._manageVisibilityControl(shouldAdd);\n    }\n\n    /**\n     * Manages controls for restarting the game.\n     * @param {boolean} shouldAdd - if true, adds the event listeners; if false, removes them.\n     */\n    manageRestartControls(shouldAdd) {\n        const action = shouldAdd ? 'addEventListener' : 'removeEventListener';\n        if (shouldAdd && !this._game.motionControl.active) {\n            // remove existing keyboard listener to avoid conflicts with new restart controls\n            document.removeEventListener('keydown', this._boundMethods.handleKeyInput);\n        }\n        document[action]('keydown', this._boundMethods.handleRestart);\n        document[action]('click', this._boundMethods.handleRestart);\n    }\n\n    /**\n     * Manages keyboard control event listeners for the game.\n     * @param {boolean} shouldAdd - if true, adds the event listeners; if false, removes them.\n     * @private\n     */\n    _manageKeyboardControls(shouldAdd) {\n        const action = shouldAdd ? 'addEventListener' : 'removeEventListener';\n        document[action]('keydown', this._boundMethods.handleKeyInput);\n    }\n\n    /**\n     * Manages touch control event listeners for the game.\n     * @param {boolean} shouldAdd - if true, adds the event listeners; if false, removes them.\n     * @private\n     */\n    _manageTouchControls(shouldAdd) {\n        const action = shouldAdd ? 'addEventListener' : 'removeEventListener';\n        this._game.board.canvas[action]('touchstart', this._boundMethods.handleTouchStart);\n        this._game.board.canvas[action]('touchend', this._boundMethods.handleTouchEnd);\n    }\n\n    /**\n     * Manages click control event listeners for the game.\n     * @param {boolean} shouldAdd - if true, adds the event listeners; if false, removes them.\n     * @private\n     */\n    _manageClickControls(shouldAdd) {\n        const action = shouldAdd ? 'addEventListener' : 'removeEventListener';\n        document[action]('click', this._boundMethods.handlePauseClick);\n        document[action]('dblclick', this._boundMethods.enterFullScreen);\n    }\n\n    /**\n     * Set up visibility change control event listeners for the game.\n     * @param {boolean} shouldAdd - if true, adds the event listeners; if false, removes them.\n     * @private\n     */\n    _manageVisibilityControl(shouldAdd) {\n        const action = shouldAdd ? 'addEventListener' : 'removeEventListener';\n        document[action]('visibilitychange', this._boundMethods.handleVisibilityChange, false);\n    }\n\n    /**\n     * Set up motion control event listeners for the game, if available.\n     * @param {boolean} shouldAdd - if true, adds the event listeners; if false, removes them.\n     * @private\n     */\n    _manageMotionControls(shouldAdd) {\n        if (typeof DeviceOrientationEvent === 'undefined') return;\n        shouldAdd ? this._listenToDeviceOrientation() : window.removeEventListener('deviceorientation', this._boundMethods.handleDeviceMovement);\n    }\n\n    /**\n     * Checks if device orientation events are supported and sets up the appropriate listeners or permission requests.\n     * If permission is required (e.g., on iOS 13+), it creates a button for the user to request permission.\n     * If permission is already granted or not required, it activates motion control immediately.\n     * @private\n     */\n    _listenToDeviceOrientation() {\n        if (typeof DeviceOrientationEvent.requestPermission === 'function') {\n            if (motionPermissionState === 'granted') {\n                this._activateMotionControl();\n            } else {\n                this._createMotionRequestButton();\n            }\n        } else {\n            window.addEventListener('deviceorientation', this._boundMethods.handleDeviceMovement);\n        }\n    }\n\n    _createMotionRequestButton() {\n        let btn = this._game.board.createMotionRequestButton();\n        if (btn) {\n            btn.classList.add('show');\n            btn.addEventListener('click', this._boundMethods.requestDeviceOrientation);\n\n            // give user time to grant permission\n            if (!this._game.state.paused) {\n                this._game.togglePause();\n            }\n\n            motionPermissionState = 'requesting';\n        }\n    }\n\n    /**\n     * Handles keyboard input.\n     * @param {KeyboardEvent} event - keyboard event\n     * @private\n     */\n    _handleKeyInput(event) {\n        const keyCommands = {\n            [LEFT_KEY]: () => this._game.snake.changeDirection(DIRECTION_LEFT),\n            [RIGHT_KEY]: () => this._game.snake.changeDirection(DIRECTION_RIGHT),\n            [UP_KEY]: () => this._game.snake.changeDirection(DIRECTION_UP),\n            [DOWN_KEY]: () => this._game.snake.changeDirection(DIRECTION_DOWN),\n            [SPACE_KEY]: () => this._game.togglePause(),\n        };\n\n        const commandFn = keyCommands[event.code];\n        if (commandFn) {\n            if (this._game.motionControl.active === null) {\n                console.log('key controls activated');\n            }\n\n            // disable motion control when keyboard is used\n            // (having both keyboard and motion event listeners makes the game less responsive)\n            this._deactivateMotionControl();\n\n            commandFn();\n        }\n    }\n\n    /**\n     * Handles click events for pausing the game.\n     * Disallows pause clicks while the game is requesting motion permission.\n     * @param {MouseEvent} event - The click event object\n     * @private\n     */\n    _handlePauseClick(event) {\n        if (motionPermissionState !== 'requesting') {\n            this._game.togglePause();\n        }\n    }\n\n    /**\n     * Handles restart events triggered by key press, click, or touch.\n     * @param {KeyboardEvent | MouseEvent | TouchEvent} event - event object\n     */\n    _handleRestart(event) {\n        if ((event instanceof KeyboardEvent && event.code === SPACE_KEY) ||\n            event.type === 'click' ||\n            event.type === 'touchend') {\n            this._game.restart();\n        }\n    }\n\n    /**\n     * Handles device motion input.\n     * @param {DeviceOrientationEvent} event - device orientation event\n     * @private\n     */\n    _handleDeviceMovement(event) {\n        const currentUpdateTime = Date.now();\n        const currentOrientation = {\n            beta: event.beta || 0,\n            gamma: event.gamma || 0\n        }\n\n        if (!this._initialOrientation) {\n            this._initialOrientation = { ...currentOrientation };\n            this._lastOrientation = { ...currentOrientation };\n            // update the game's motion control state with initial orientation\n            this._game.updateMotionControl(currentOrientation, null, this._sensitivityMultiplier);\n            return;\n        }\n\n        const { direction, sensitivity } = calculateMotionControl(\n            currentOrientation,\n            this._lastOrientation,\n            currentUpdateTime,\n            this._lastOrientationUpdateTime\n        );\n\n        this._sensitivityMultiplier = sensitivity;\n\n        if (direction) {\n            // used to determine when to switch from keyboard to motion controls\n            if (this._game.motionControl.active === null) {\n                this._activateMotionControl();\n            }\n\n            this._game.snake.changeDirection(direction);\n            this._lastOrientationUpdateTime = currentUpdateTime;\n            this._lastOrientation = currentOrientation;\n        }\n\n        this._game.updateMotionControl(\n            currentOrientation,\n            this._game.snake.getCurrentDirection(),\n            this._sensitivityMultiplier\n        );\n    }\n\n    /**\n     * Handles visibility change of the document.\n     * @private\n     */\n    _handleVisibilityChange() {\n        if (document.hidden && !this._game.state.paused) {\n            this._game.togglePause();\n        }\n    }\n\n    /**\n     * Handles the touch start event.\n     * Records the initial Y position of the touch.\n     * @param {TouchEvent} event - touch start event\n     * @private\n     */\n    _handleTouchStart(event) {\n        event.preventDefault();\n\n        const firstTouch = event.changedTouches[0];\n        // console.log({\n        //     [ev.type]: (firstTouch.screenX, firstTouch.screenY)\n        // });\n\n        this._touchStart = { x: firstTouch.screenX, y: firstTouch.screenY };\n    }\n\n    /**\n     * Handles the touch end event.\n     * Records the final Y position of the touch and calls handleSwipeGesture.\n     * @param {TouchEvent} event - touch end event\n     * @private\n     */\n    _handleTouchEnd(event) {\n        event.preventDefault();\n\n        const firstTouch = event.changedTouches[0];\n        // console.log({\n        //     [ev.type]: (firstTouch.screenX, firstTouch.screenY)\n        // });\n\n        this._touchEnd = { x: firstTouch.screenX, y: firstTouch.screenY };\n\n        this._handleSwipeGesture();\n    }\n\n    /**\n     * Handles the gesture based on the swipe direction.\n     * Enters fullscreen on upward swipe, exits fullscreen on downward swipe,\n     * restarts the game if it has ended, or toggles pause otherwise.\n     * @private\n     */\n    _handleSwipeGesture() {\n        const verticalSwipe = this._touchStart.y - this._touchEnd.y;\n        if (verticalSwipe > INPUT.SWIPE_SENSITIVITY) {\n            // console.log(`swiped UP ${downY-upY}px`);\n            this._game.board.enterFullScreen();\n        } else if (verticalSwipe < -INPUT.SWIPE_SENSITIVITY) {\n            // console.log(`swiped DOWN ${upY-downY}px`);\n            this._game.board.exitFullScreen();\n        } else if (this._game.state.ended) {\n            this._game.restart();\n        } else if (motionPermissionState !== 'requesting') {\n            // console.log(`togglePause from handleGesture`);\n            this._game.togglePause();\n        }\n    }\n\n    /**\n     * Request device orientation permission.\n     * @private\n     */\n    _requestDeviceOrientation() {\n        // iOS 13+ requires permission\n        DeviceOrientationEvent.requestPermission()\n            .then(state => {\n                motionPermissionState = state;\n                if (state === 'granted') {\n                    this._activateMotionControl();\n                    if (this._game.state.paused) {\n                        this._game.togglePause();\n                    }\n                } else {\n                    console.log('motion permission denied');\n                }\n            })\n            .catch(console.error)\n            .finally(() => {\n                this._game.board.removeMotionRequestButton();\n            });\n    }\n\n    /**\n     * Enables motion control for the game.\n     * @private\n     */\n    _activateMotionControl() {\n        document.removeEventListener('keydown', this._boundMethods.handleKeyInput);\n        window.addEventListener('deviceorientation', this._boundMethods.handleDeviceMovement);\n\n        this._game.board.removeMotionRequestButton();\n        this._game.activateMotionControl();\n\n        console.log('motion controls activated');\n    }\n\n    /**\n     * Disables motion control for the game.\n     * @private\n     */\n    _deactivateMotionControl() {\n        this._game.board.removeMotionRequestButton();\n        window.removeEventListener('deviceorientation', this._handleDeviceMovement);\n        this._game.deactivateMotionControl();\n    }\n\n    /**\n     * Logs debug information about the current state of motion controls.\n     * This method is intended to be called periodically (e.g., in the game loop)\n     * to provide ongoing insight into the motion control system's state.\n     * @private\n     */\n    _debugMotionControl() {\n        console.log('motion control debug info', {\n            motionControlActive: this._game.motionControl.active,\n            motionPermissionState: motionPermissionState,\n            deviceOrientation: this._lastOrientation,\n            isChangingDirection: this._game.snake._isChangingDirection,\n            snakeDirection: this._game.snake.getCurrentDirection()\n        });\n    }\n\n    /**\n     * Simulates the presence of the DeviceOrientationEvent.requestPermission API.\n     * This method is useful for testing or development environments where the actual API might not be available.\n     * It creates a mock DeviceOrientationEvent object with a requestPermission method that always resolves to 'granted'.\n     * @static\n     * @private\n     */\n    static _simulateDeviceOrientationRequestPermission() {\n        // create DeviceOrientationEvent if it doesn't exist\n        if (typeof DeviceOrientationEvent === 'undefined') {\n            window.DeviceOrientationEvent = {};\n        }\n\n        // add requestPermission method\n        window.DeviceOrientationEvent.requestPermission = () => {\n            return new Promise((resolve) => {\n                resolve('granted');\n            });\n        };\n\n        // modify typeof operator for requestPermission\n        Object.defineProperty(Object.prototype, 'requestPermission', {\n            value: function() {}\n        });\n    }\n}\n\n// TODO: consider refactoring to use Command interface again if\n// key controls AND mouse/touch/motion controls can all use it\n\n/**\n * Represents a command to pause the game.\n */\nclass PauseCommand {\n\n    /**\n     * Executes the pause command.\n     * @param {import('./game').Game} game - game instance\n     */\n    execute(game) {\n        game.togglePause();\n    }\n}\n\n/**\n * Represents a command to move snek.\n */\nclass MoveCommand {\n\n    /**\n     * @param {string} direction - direction to move\n     */\n    constructor(direction) {\n        this.direction = direction;\n    }\n\n    /**\n     * Executes the move command.\n     * @param {import('./game').Game} game - game instance\n     */\n    execute(game) {\n        game.snake.changeDirection(this.direction);\n    }\n}\n","import { GAME_CONFIG } from './config';\n\nconst { CANVAS } = GAME_CONFIG;\n\nconst PAUSE_ICON_CHAR_CODE = 0xF4BF;\nconst EXCLAMATION_ICON_CHAR_CODE = 0xF33A;\n\n/**\n * A fake \"context manager\" for pixel sharpness.\n * https://stackoverflow.com/a/8696641\n * @param {CanvasRenderingContext2D} ctx - canvas rendering context\n * @param {() => void} cb - callback function to execute within the context\n */\nfunction withStraddle(ctx, cb) {\n    const offset = 0.5;\n\n    try {\n        // turn on 'straddle' trick to avoid blurriness\n        ctx.translate(offset, offset);\n        cb();\n    } finally {\n        // turn off 'straddle' trick to avoid blurriness\n        ctx.translate(-offset, -offset);\n    }\n}\n\n/**\n * Draws the game board and background.\n * @param {import('./game/game').Game} game - game object\n */\nexport function drawGame(game) {\n    let board = game.board;\n    let ctx = board.ctx;\n\n    ctx.save();\n\n    withStraddle(ctx, () => {\n        ctx.filter = board.activeFilter;\n\n        // set border and background colors\n        ctx.fillStyle = board.color;\n        if (board.isGlowing) {\n            // note: strokeRect doesn't do a good job of bordering the canvas,\n            // so we fall back to CSS styling\n\n            // https://stackoverflow.com/a/5670984\n            board.canvas.style.border = 'none'\n            board.canvas.style.outline = `${board.borderColor} dashed thin`;\n            board.canvas.style.boxShadow = `0 0 10px ${board.color}`;\n            board.canvas.style.transition = 'box-shadow linear 1s';\n        } else {\n            board.canvas.style.border = `2px solid ${board.borderColor}`;\n            board.canvas.style.outline = 'none';\n            board.canvas.style.boxShadow = 'none';\n            board.canvas.style.transition = 'box-shadow linear 0.5s';\n        }\n\n        ctx.fillRect(0, 0, board.canvas.width, board.canvas.height);\n\n        if (game.state.paused) {\n            let useExclamation = board.needsPermission();\n\n            const iconSize = CANVAS.GAME_TEXT_FONT_SIZE * board.ratio;\n            const iconPadding = 5 * board.ratio;\n\n            // since filters don't work on iOS safari, we need another visual aid\n            // add pause button icon https://icons.getbootstrap.com/icons/pause-btn-fill/\n            // or exclamation triangle icon if we still need permissions\n            // https://icons.getbootstrap.com/icons/exclamation-triangle-fill/\n            ctx.font = `${iconSize}px \"bootstrap-icons\"`;\n            ctx.fillStyle = useExclamation ? CANVAS.EXCLAMATION_BTN_COLOR : CANVAS.PAUSE_BTN_COLOR;\n            ctx.fillText(String.fromCharCode(\n                useExclamation ? EXCLAMATION_ICON_CHAR_CODE : PAUSE_ICON_CHAR_CODE\n            ), iconPadding, iconSize + iconPadding, board.canvas.width);\n        }\n    });\n\n    ctx.restore();\n}\n\n/**\n * Draws snek on the game board.\n * @param {import('./snake').Snake} snake - snek object\n * @param {import('./board').Board} board - game board\n */\nexport function drawSnake(snake, board) {\n    const ctx = board.ctx;\n\n    ctx.save();\n\n    withStraddle(ctx, () => {\n        if (snake.isGlowing) {\n            // https://stackoverflow.com/a/43676108\n            ctx.lineCap = 'round';\n            ctx.shadowBlur = 18;\n            ctx.shadowColor = snake.color;\n        }\n\n        ctx.fillStyle = snake.color;\n        ctx.strokeStyle = snake.borderColor;\n\n        snake.forEachSegment((/** @type {{ x: number; y: number; }} */ segment) => {\n            ctx.fillRect(segment.x, segment.y, board.blockSize, board.blockSize);\n            ctx.strokeRect(segment.x, segment.y, board.blockSize, board.blockSize);\n        });\n    });\n\n    ctx.restore();\n}\n\n/**\n * Draws an item on the game board.\n * @param {import('./item').Item} item - item object\n * @param {import('./board').Board} board - game board\n */\nexport function drawItem(item, board) {\n    let ctx = board.ctx;\n    ctx.save();\n\n    withStraddle(ctx, () => {\n        ctx.fillStyle = item.fillColor;\n        ctx.strokeStyle = item.borderColor;\n        ctx.fillRect(item.x, item.y, board.blockSize, board.blockSize);\n        ctx.strokeRect(item.x, item.y, board.blockSize, board.blockSize);\n    });\n\n    ctx.restore();\n}\n\n/**\n * Draws the current score on the game board.\n * @param {number} score - current score\n * @param {import('./board').Board} board - game board\n */\nexport function drawScore(score, board) {\n    let ctx = board.ctx;\n    ctx.save();\n\n    ctx.font = `${CANVAS.GAME_TEXT_FONT_SIZE * board.ratio}px ${CANVAS.GAME_TEXT_FONT_FAMILY}`;\n    ctx.textAlign = 'center';\n    ctx.fillStyle = CANVAS.GAME_TEXT_COLOR;\n    ctx.fillText(score.toString(), board.canvas.width / 2, (board.canvas.height / 2) - ((CANVAS.GAME_TEXT_FONT_SIZE / 2) * board.ratio), board.canvas.width);\n\n    ctx.restore();\n}\n\n/**\n * Draws the high score on the game board.\n * @param {number} score - high score\n * @param {import('./board').Board} board - game board\n */\nexport function drawHighScore(score, board) {\n    let ctx = board.ctx;\n    ctx.save();\n\n    ctx.font = `${CANVAS.GAME_TEXT_FONT_SIZE * board.ratio}px ${CANVAS.GAME_TEXT_FONT_FAMILY}`;\n    ctx.textAlign = 'center';\n    ctx.strokeStyle = CANVAS.HIGH_SCORE_TEXT_COLOR;\n    ctx.strokeText(score.toString(), board.canvas.width / 2, (board.canvas.height / 2) + ((CANVAS.GAME_TEXT_FONT_SIZE / 2) * board.ratio), board.canvas.width);\n\n    ctx.restore();\n}\n\n/**\n * Draws the game over message on the game board.\n * @param {import('./board').Board} board - game board\n */\nexport function drawGameOver(board) {\n    let ctx = board.ctx;\n    ctx.save();\n\n    ctx.font = `${CANVAS.GAME_TEXT_FONT_SIZE * board.ratio}px ${CANVAS.GAME_TEXT_FONT_FAMILY}`;\n    ctx.textAlign = 'center';\n    ctx.fillStyle = CANVAS.GAME_TEXT_COLOR;\n    ctx.fillText('DED', board.canvas.width / 2, board.canvas.height / 2, board.canvas.width);\n\n    ctx.restore();\n}\n","import * as defaultCanvas from '../canvas';\n\n// fn to create render functions with canvas as injected dependency\nexport function createRenderFunctions(canvas = defaultCanvas) {\n    /**\n     * Renders the current game state.\n     * @param {import('./game').Game} game - game object to render\n     */\n    function renderGame(game) {\n        canvas.drawGame(game);\n        canvas.drawScore(game.state.score, game.board);\n        canvas.drawHighScore(game.state.highScore, game.board);\n        canvas.drawItem(game.item, game.board);\n        canvas.drawSnake(game.snake, game.board);\n    }\n\n    /**\n     * Renders the game over state.\n     * @param {import('./game').Game} game - game object to render\n     */\n    function renderGameOver(game) {\n        game.board.setEndGameFilter();\n        canvas.drawGame(game);\n        canvas.drawItem(game.item, game.board);\n        canvas.drawSnake(game.snake, game.board);\n        canvas.drawGameOver(game.board);\n    }\n\n    return { renderGame, renderGameOver };\n}\n\n// export the default render functions\nconst { renderGame, renderGameOver } = createRenderFunctions();\nexport { renderGame, renderGameOver };\n","import { GAME_CONFIG } from '../config';\n\nconst { GAME, STATE } = GAME_CONFIG;\n\n/**\n * Represents the state of the game.\n */\nexport class GameState {\n\n    constructor() {\n        // states\n        this._paused = false;\n        this._ended = false;\n\n        // values\n        this._score = 0;\n        this._highScore = this._getItemSafely(STATE.LOCAL_STORAGE_KEY_HIGH_SCORE, 0);\n        this._speed = this._getItemSafely(STATE.LOCAL_STORAGE_KEY_GAME_SPEED, GAME.SPEED_MS__ARROW);\n    }\n\n    /**\n     * Gets the speed of the game, aka time between frame updates, in milliseconds.\n     * @returns {number} game speed\n     */\n    get speed() {\n        return this._speed;\n    }\n\n    /**\n     * Gets the current score of the game.\n     * @returns {number} current score\n     */\n    get score() {\n        return this._score;\n    }\n\n    /**\n     * Gets the high score of all games.\n     * @returns {number} high score\n     */\n    get highScore() {\n        return this._highScore;\n    }\n\n    /**\n     * Gets whether or not the game is paused.\n     * @returns {boolean} true if game is paused; false otherwise\n     */\n    get paused() {\n        return this._paused;\n    }\n\n    /**\n     * Gets whether or not the game has ended.\n     * @returns {boolean} true if game has ended; false otherwise\n     */\n    get ended() {\n        return this._ended;\n    }\n\n    /**\n     * Updates the current score.\n     * @param {number} increment - amount to increase the score by\n     */\n    updateScore(increment) {\n        this._score += increment;\n    }\n\n    /**\n     * Updates the high score if the current score is higher.\n     */\n    updateHighScore() {\n        if (this.score > this.highScore) {\n            this._highScore = this.score;\n            this._setItemSafely(STATE.LOCAL_STORAGE_KEY_HIGH_SCORE, this.score);\n        }\n    }\n\n    /**\n     * Resets the high score to 0 and persists this change to localStorage.\n     * This operation cannot be undone.\n     */\n    clearHighScore() {\n        this._highScore = 0;\n        this._setItemSafely(STATE.LOCAL_STORAGE_KEY_HIGH_SCORE, 0);\n    }\n\n    /**\n     * Sets the game speed.\n     * @param {number} speed - new game speed to use\n     */\n    setSpeed(speed) {\n        if (typeof speed !== 'number' || isNaN(speed)) {\n            return;\n        }\n        this._speed = Math.max(0, Math.round(speed));\n    }\n\n    /**\n     * Toggles the pause state of the game.\n     */\n    togglePause() {\n        this._paused = !this.paused;\n    }\n\n    /**\n     * Ends the game and saves the current game speed.\n     */\n    endGame() {\n        this._ended = true;\n        this._setItemSafely(STATE.LOCAL_STORAGE_KEY_GAME_SPEED, this.speed);\n    }\n\n    /**\n     * Safely gets an item from localStorage.\n     * @param {string} key - The key to retrieve from localStorage\n     * @param {*} defaultValue - The default value to return if retrieval fails\n     * @returns {*} The value from localStorage or the default value\n     * @private\n     */\n    _getItemSafely(key, defaultValue) {\n        try {\n            const value = localStorage.getItem(key);\n            return value !== null ? JSON.parse(value) : defaultValue;\n        } catch (error) {\n            console.warn(`Error reading from localStorage: ${error.message}`);\n            return defaultValue;\n        }\n    }\n\n    /**\n     * Safely sets an item in localStorage.\n     * @param {string} key - The key to set in localStorage\n     * @param {*} value - The value to set\n     * @private\n     */\n    _setItemSafely(key, value) {\n        try {\n            localStorage.setItem(key, JSON.stringify(value));\n        } catch (error) {\n            console.warn(`Error writing to localStorage: ${error.message}`);\n        }\n    }\n}\n","import { Board } from '../board';\nimport { GAME_CONFIG } from '../config';\nimport { displayErrorMessage } from '../error';\nimport { Food, Item, Phase, TELEPORT_CLASSNAME, Teleport, selectRandomItem } from '../item';\nimport { MotionControlIndicator } from '../motion';\nimport { Snake } from '../snake';\nimport { InputHandler } from './input';\nimport { renderGame, renderGameOver } from './render';\nimport { GameState } from './state';\n\nconst { GAME } = GAME_CONFIG;\n\nconst CANVAS_ID = 'gameCanvas';\nconst CONTROL_PANEL_ID = 'controlPanel';\nconst MOTION_INDICATOR_ID = 'motionIndicator';\n\n/**\n * global var to persist indicator visibility across game sessions.\n * */\nlet motionIndicatorVisible = false;\n\n/**\n * Represents the main game logic and state.\n */\nexport class Game {\n\n    /**\n     * @param {Board} board - game board\n     * @param {Snake} snake - snek\n     * @param {Item} item - current game item\n     */\n    constructor(board, snake, item) {\n        this.board = board;\n        this.snake = snake;\n        this.item = item;\n\n        this.state = new GameState();\n        this.input = new InputHandler(this);\n\n        this._lastUpdateTimestamp = 0;\n\n        /**\n         * @type {{\n        *   active: boolean | null,\n        *   orientation: { beta: number, gamma: number },\n        *   direction: string | null,\n        *   indicatorVisible: boolean,\n        *   sensitivity: number\n        * }}\n        */\n        this.motionControl = {\n            active: null,\n            orientation: { beta: 0, gamma: 0 },\n            direction: null,\n            indicatorVisible: motionIndicatorVisible,\n            sensitivity: 1\n        };\n\n        this._boundMethods = {\n            handleClearHighScore: this._handleClearHighScore.bind(this),\n            handleToggleMotionIndicator: this._handleToggleMotionIndicator.bind(this)\n        };\n\n        this._initializeUI();\n    }\n\n    /**\n     * Runs the game loop.\n     * @param {DOMHighResTimeStamp} now - current timestamp\n     */\n    run(now) {\n        if (this._shouldUpdateFrame(now)) {\n            this._updateFrame();\n            if (this.state._ended) {\n                renderGameOver(this);\n                return;\n            } else {\n                renderGame(this);\n            }\n        }\n\n        // run game loop again\n        requestAnimationFrame((t) => this.run(t));\n    }\n\n    /**\n     * Toggles pause state of the game.\n     */\n    togglePause() {\n        this.state.togglePause();\n\n        if (this.state.paused) {\n            this.snake.pause();\n            this.board.setPauseGameFilter();\n        } else {\n            this.snake.unpause();\n            this.board.resetFilter();\n        }\n\n        // TODO: pause/unpause any game sounds\n        // this.audio.togglePause();\n\n        console.log(`game ${this.state.paused ? 'paused' : 'resumed'}`);\n    }\n\n    /**\n     * Restarts the game.\n     */\n    restart() {\n        this.input.manageRestartControls(false);\n        this._removeEventListeners();\n        console.log('game restarted');\n        runGame();\n    }\n\n    updateMotionControl(orientation, direction, sensitivity) {\n        this.orientation = orientation;\n        this.motionDirection = direction;\n        this.motionSensitivity = sensitivity;\n        if (this.motionIndicator) {\n            this.motionIndicator.update(orientation, direction, sensitivity);\n        }\n    }\n\n    /**\n     * Determines if the current frame of the game loop should be updated.\n     * @param {DOMHighResTimeStamp} now - current timestamp\n     * @returns {boolean} true if the frame should update; false otherwise\n     * @private\n     */\n    _shouldUpdateFrame(now) {\n        if (now - this._lastUpdateTimestamp >= this.state.speed) {\n            this._lastUpdateTimestamp = now;\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Updates the current frame based on game logic.\n     * This method checks the game state and advances snek as necessary.\n     * @private\n     */\n    _updateFrame() {\n        if (this.state.ended) return;\n        if (!this.state.paused) {\n            this._advanceSnake();\n            // TODO: add to control panel\n            // this.input._debugMotionControl();\n        }\n    }\n\n    _initializeUI() {\n        const uiContainer = document.getElementById(UI_CONTAINER_ID);\n        if (!uiContainer) {\n            console.warn(`UI container with id '${UI_CONTAINER_ID}' not found. Motion control indicator will not be displayed.`);\n            return;\n        }\n\n        this.motionIndicator = new MotionControlIndicator(uiContainer, {\n            showInfo: false,\n            position: 'corner'\n        });\n    }\n\n    /**\n     * Snek movement, collision, and item consumption logic.\n     * @private\n     */\n    _advanceSnake() {\n        let didEatBeforeMove = this.snake.didEat(this.item);\n\n        // move snek, growing if it ate an item\n        this.snake.move(didEatBeforeMove);\n\n        if (didEatBeforeMove) {\n            console.log(`snek ate item: ${this.item.type.toUpperCase()}`);\n\n            this.state.updateScore(GAME.SCORE_INCREMENT);\n\n            // apply item effects\n            this.snake.equip(this.item);\n\n            // update board effects if necessary\n            this.board.setGlow(this.snake.powerUps[TELEPORT_CLASSNAME]);\n\n            // generate a new item\n            this._generateNewItem();\n        } else {\n            // optionally regenerate item based on game conditions\n            this._maybeRegenerateItem();\n        }\n\n        // TODO: add to control panel\n        // console.log(`${this.item.type}: ${this.item.x}, ${this.item.y}`);\n\n        if (this._checkCollision()) {\n            this._end();\n        }\n    }\n\n    /**\n     * Generates a new item on the board.\n     * @private\n     */\n    _generateNewItem() {\n        let itemClass = selectRandomItem(this.state.score, this.snake.powerUps,\n            { alwaysReturnItem: true, reducePowerUpProbability: false }\n        );\n        if (itemClass !== null) {\n            this.item = new itemClass(this.board, this.snake);\n            console.log(`new item generated: ${this.item.type.toUpperCase()}`);\n        }\n    }\n\n    /**\n     * Possibly regenerates the current item based on game conditions:\n     * (1) when the player is already performing well (high score),\n     * we make the food volatile, or able to change or disappear, like power-ups are.\n     * (2) when there's already a power-up on the board, we reduce the chance of chain-spawning power-ups.\n     * @private\n     */\n    _maybeRegenerateItem() {\n        const foodIsVolatile = this.state.score >= GAME.SCORE_THRESHOLD_FOR_VOLATILE_FOOD;\n        if (foodIsVolatile || this.item instanceof Teleport || this.item instanceof Phase) {\n            let itemClass = selectRandomItem(this.state.score, this.snake.powerUps,\n                {alwaysReturnItem: false, reducePowerUpProbability: true}\n            );\n            if (itemClass !== null) {\n                this.item = new itemClass(this.board, this.snake);\n                console.log(`item regenerated: ${this.item.type.toUpperCase()}`);\n            }\n        }\n    }\n\n    /**\n     * Checks if snek has collided with the board boundaries or itself.\n     * @returns {boolean} true if a collision occurred; false otherwise\n     * @private\n     */\n    _checkCollision() {\n        // always set game board glow based on whether or not teleport powerup is equipped\n        this.board.setGlow(this.snake.powerUps[TELEPORT_CLASSNAME]);\n        return this.snake.didCollide(this.board.width, this.board.height, this.board.blockSize);\n    }\n\n    /**\n     * Ends the game and updates final state.\n     * @private\n     */\n    _end() {\n        this.state.endGame();\n        this.state.updateHighScore();\n\n        this.input.manageGameControls(false);\n        this.input.manageRestartControls(true);\n\n        console.log(`game over - final score: ${this.state.score}; high score: ${this.state.highScore}`);\n    }\n\n    /**\n     * Resets the high score to zero and logs the change.\n     * Updates the game state but does not trigger a re-render.\n     * @private\n     */\n    _clearHighScore() {\n        const oldHighScore = this.state.highScore;\n        this.state.clearHighScore();\n        console.log(`high score cleared. old high score: ${oldHighScore}`);\n    }\n\n    /**\n     * Updates the motion control state with new orientation and direction values.\n     * If motion control is not already active, this will activate it.\n     * Also updates the motion indicator UI if it's visible.\n     *\n     * @param {{ beta: number, gamma: number }} orientation - current device orientation angles\n     * @param {string|null} direction - current movement direction of the snake ('left', 'right', 'up', 'down', or null)\n     */\n    updateMotionControl(orientation, direction) {\n        this.motionControl.orientation = orientation;\n        if (direction) {\n            this.motionControl.direction = direction;\n        }\n\n        if (this.motionControl.active === null) {\n            this.activateMotionControl();\n        }\n\n        if (this.motionIndicator && this.motionControl.indicatorVisible) {\n            this.motionIndicator.update(orientation, direction);\n        }\n    }\n\n    /**\n     * Activates motion controls for the game.\n     * Sets the game speed to motion-appropriate speed, shows the motion indicator toggle button,\n     * and updates the motion control state to active.\n     */\n    activateMotionControl() {\n        this.motionControl.active = true;\n        this.state.setSpeed(GAME.SPEED_MS__MOTION);\n        this.board.showMotionIndicatorToggleButton();\n    }\n\n    /**\n     * Deactivates motion controls for the game.\n     * Hides the motion indicator, resets to default game speed,\n     * hides the motion indicator toggle button, and updates the motion control state.\n     */\n    deactivateMotionControl() {\n        this.motionControl.active = false;\n        this.motionControl.indicatorVisible = false;\n        if (this.motionIndicator) {\n            this.motionIndicator.hide();\n        }\n        this.state.setSpeed(GAME.SPEED_MS__ARROW);\n        this.board.hideMotionIndicatorToggleButton();\n    }\n\n    // <!-- UI HELPER METHODS BELOW -->\n    // <!-- TODO: fully refactor to be in Board instead, without circular dep (GameEngine) ? -->\n\n    /**\n     * Initializes all UI components for the game / control panel.\n     * Sets up the motion indicator, motion toggle button, and high score clear button.\n     * @private\n     */\n    _initializeUI() {\n        this._setupMotionIndicator();\n        this._setupMotionToggleButton();\n        this._setupClearHighScoreButton();\n    }\n\n    /**\n     * Sets up the motion control indicator UI component.\n     * Creates a new MotionControlIndicator if the required DOM element exists,\n     * otherwise logs a warning and continues without the indicator.\n     * @private\n     */\n    _setupMotionIndicator() {\n        const motionIndicatorDiv = document.getElementById(MOTION_INDICATOR_ID);\n        if (!(motionIndicatorDiv instanceof HTMLDivElement)) {\n            console.warn(`Div with id '${MOTION_INDICATOR_ID}' not found. Motion control indicator will not be displayed.`);\n            return;\n        }\n\n        this.motionIndicator = new MotionControlIndicator(motionIndicatorDiv, {\n            showInfo: false,\n            position: 'corner'\n        });\n\n        if (this.motionControl.indicatorVisible) {\n            this.motionIndicator.show();\n        } else {\n            this.motionIndicator.hide();\n        }\n        this.board.updateMotionIndicatorToggleButtonTitle(this.motionControl.indicatorVisible);\n    }\n\n    /**\n     * Sets up the motion indicator toggle button.\n     * Creates the button and attaches the toggle event handler.\n     * @private\n     */\n    _setupMotionToggleButton() {\n        const toggleButton = this.board.createMotionIndicatorToggleButton();\n        if (toggleButton) {\n            toggleButton.addEventListener('click', this._boundMethods.handleToggleMotionIndicator);\n        }\n    }\n\n    /**\n     * Sets up the clear high score button.\n     * Creates the button and attaches the clear score event handler.\n     * @private\n     */\n    _setupClearHighScoreButton() {\n        const clearButton = this.board.createClearHighScoreButton();\n        if (clearButton) {\n            clearButton.addEventListener('click', this._boundMethods.handleClearHighScore);\n        }\n    }\n\n    /**\n     * Handles toggling the motion indicator's visibility.\n     * Prevents default event behavior and propagation, then updates\n     * both the indicator's visibility state and the toggle button's title.\n     * @private\n     * @param {MouseEvent} event - click event object\n     */\n    _handleToggleMotionIndicator(event) {\n        this.motionControl.indicatorVisible = !this.motionControl.indicatorVisible;\n        motionIndicatorVisible = this.motionControl.indicatorVisible;\n\n        event.preventDefault();\n        event.stopPropagation();\n\n        if (this.motionIndicator && this.motionControl.indicatorVisible) {\n            this.motionIndicator.show();\n        } else if (this.motionIndicator) {\n            this.motionIndicator.hide();\n        }\n        this.board.updateMotionIndicatorToggleButtonTitle(this.motionControl.indicatorVisible);\n    }\n\n    /**\n     * Handles clearing the high score.\n     * Prevents default event behavior and propagation, then clears the high score.\n     * @private\n     * @param {MouseEvent} event - click event object\n     */\n    _handleClearHighScore(event) {\n        event.preventDefault();\n        event.stopPropagation();\n        this._clearHighScore();\n    }\n\n    /**\n     * Removes all event listeners added during game initialization.\n     * @private\n     */\n    _removeEventListeners() {\n        const clearButton = this.board.getClearHighScoreButton();\n        if (clearButton) {\n            clearButton.removeEventListener('click', this._boundMethods.handleClearHighScore);\n        }\n\n        const toggleButton = this.board.getMotionIndicatorToggleButton();\n        if (toggleButton) {\n            toggleButton.removeEventListener('click', this._boundMethods.handleToggleMotionIndicator);\n        }\n    }\n}\n\n// <!-- GAME EXECUTION HELPERS BELOW -->\n\n/**\n * Initializes and runs the game.\n */\nexport function runGame() {\n    try {\n        let board = _initBoard();\n        let snake = new Snake(board.height, board.height, board.blockSize);\n        let food = new Food(board, snake);\n        let game = new Game(board, snake, food);\n\n        game.input.manageGameControls(true);\n\n        requestAnimationFrame((t) => game.run(t));\n    } catch (error) {\n        console.error('failed to initialize game:', error);\n        // display an error message to the user\n        displayErrorMessage('Failed to start the game. Please refresh the page and try again.', document.getElementById(CANVAS_ID));\n    }\n}\n\n/**\n * Initializes the game board.\n * @returns {Board} initialized game board\n * @throws {Error} ff the canvas element is not found or is not an HTMLCanvasElement\n * @private\n */\nfunction _initBoard() {\n    let canvas, ctrl_panel;\n    if (!(canvas = document.getElementById(CANVAS_ID))) {\n        throw new Error(`HTML canvas with id '${CANVAS_ID}' not found`);\n    }\n    if (!(canvas instanceof HTMLCanvasElement)) {\n        throw new Error(`#${CANVAS_ID} element is not an HTML canvas`);\n    }\n    if (!(ctrl_panel = document.getElementById(CONTROL_PANEL_ID))) {\n        console.warn(`control panel element with id '${CONTROL_PANEL_ID}' not found`);\n    }\n    if (!(ctrl_panel instanceof HTMLDivElement)) {\n        console.warn(`#${CONTROL_PANEL_ID} element is not a div`);\n        ctrl_panel = null;\n    }\n    if (ctrl_panel === null) {\n        console.warn('proceeding without control panel')\n    }\n\n    let board = new Board(canvas, ctrl_panel);\n\n    return board;\n}\n","import { runGame } from './game/game';\n\n// note: un-comment for debugging\n// import { InputHandler } from './game/input';\n// InputHandler._simulateDeviceOrientationRequestPermission();\n\nrunGame();\n"],"names":["GAME_CONFIG","BOARD","CTRL_PANEL_HEIGHT","MARGIN_SIZE","NUM_STEPS_ACROSS_CANVAS","DEFAULT_BACKGROUND_COLOR","DEFAULT_BORDER_COLOR","TELEPORT_BORDER_COLOR","TELEPORT_BACKGROUND_COLOR","FILTERS","NONE","PAUSE","ENDGAME","SNAKE","INITIAL_LENGTH","DEFAULT_COLOR","PHASE_BORDER_COLOR","ITEM","FOOD_COLOR","FOOD_BORDER_COLOR","PHASE_COLOR","TELEPORT_COLOR","PHASE_SCORE_THRESHOLD","TELEPORT_SCORE_THRESHOLD","BASE_PHASE_PROBABILITY","BASE_TELEPORT_PROBABILITY","BASE_VOLATILE_FOOD_PROBABILITY","GAME","SCORE_INCREMENT","SCORE_THRESHOLD_FOR_VOLATILE_FOOD","SPEED_MS__ARROW","SPEED_MS__MOTION","INPUT","SWIPE_SENSITIVITY","MOTION_SENSITIVITY","MOTION_THROTTLE_TIME_MS","MOTION_DEADZONE","DOMINANT_DIRECTION_THRESHOLD","CANVAS","GAME_TEXT_COLOR","HIGH_SCORE_TEXT_COLOR","PAUSE_BTN_COLOR","EXCLAMATION_BTN_COLOR","GAME_TEXT_FONT_FAMILY","GAME_TEXT_FONT_SIZE","STATE","LOCAL_STORAGE_KEY_HIGH_SCORE","LOCAL_STORAGE_KEY_GAME_SPEED","ERROR","MESSAGE_FONT","MESSAGE_COLOR","MESSAGE_BACKGROUND","BUTTON_IDS","Board","constructor","canvas","ctrlPanel","this","_canvas","_ctrlPanel","ctx","getContext","Error","_boardSize","_calculateBoardSize","_ratio","window","devicePixelRatio","_sizeCanvas","_sizeControlPanel","_width","width","_height","height","_blockSize","_activeFilter","_color","_borderColor","_isGlowing","resetFilter","color","borderColor","isGlowing","activeFilter","blockSize","ratio","setEndGameFilter","setPauseGameFilter","enterFullScreen","requestFullscreen","then","screen","lockOrientationUniversal","lockOrientation","mozLockOrientation","msLockOrientation","e","exitFullScreen","document","exitFullscreen","createMotionRequestButton","_createOrGetButton","getMotionRequestButton","_getButton","removeMotionRequestButton","btn","parentNode","removeChild","createMotionIndicatorToggleButton","style","getMotionIndicatorToggleButton","showMotionIndicatorToggleButton","toggleButton","classList","remove","add","hideMotionIndicatorToggleButton","updateMotionIndicatorToggleButtonTitle","isIndicatorVisible","title","createClearHighScoreButton","getClearHighScoreButton","setGlow","shouldGlow","needsPermission","requestButton","checkVisibility","computedStyle","getComputedStyle","display","visibility","gridBlockSize","Math","min","innerWidth","innerHeight","floor","id","text","options","existingBtn","createElement","type","textContent","cssText","appendChild","element","getElementById","HTMLButtonElement","displayErrorMessage","message","HTMLCanvasElement","console","error","displayErrorInDOM","save","font","fillStyle","messageWidth","measureText","messageHeight","messageX","messageY","fillRect","textAlign","textBaseline","fillText","restore","displayErrorOnCanvas","errorDiv","position","top","left","transform","backgroundColor","padding","borderRadius","zIndex","whiteSpace","maxWidth","overflowWrap","body","PHASE_CLASSNAME","TELEPORT_CLASSNAME","Item","board","snake","_x","Number","MIN_SAFE_INTEGER","_y","_generate","x","y","fillColor","_randomBlock","forEachSegment","snakeSegment","max","round","random","Food","Teleport","Phase","ITEM_TYPES","none","food","teleport","phase","selectRandomItem","score","powerUps","alwaysReturnItem","reducePowerUpProbability","itemChances","teleportProb","calculateTeleportProbability","phaseProb","calculatePhaseProbability","foodProb","noItemProb","probabilities","totalProb","Object","values","reduce","sum","prob","abs","calculateItemProbabilities","selectedItemType","chances","cumulativeProbability","item","probability","entries","pickItem","DIRECTION_LEFT","DIRECTION_RIGHT","DIRECTION_UP","DIRECTION_DOWN","DIRECTIONS","dx","dy","MotionControlIndicator","container","showInfo","_create","update","orientation","direction","sensitivity","beta","gamma","maxTilt","tiltX","tiltY","dotPx","dot","HTMLDivElement","arrows","forEach","arrow","activeArrow","querySelector","toLowerCase","directionValue","HTMLSpanElement","setTimeout","betaValue","toFixed","gammaValue","sensitivityValue","show","hide","innerHTML","querySelectorAll","_addStyles","head","calculateMotionControl","currentOrientation","initialOrientation","lastOrientation","currentUpdateTime","lastUpdateTime","sensitivityMultiplier","totalChange","recentChange","newSensitivityMultiplier","sqrt","adjustedDeadzone","orientationChange","threshold","isSignificantMotion","absBeta","absGamma","getDirectionFromOrientation","Snake","boardWidth","boardHeight","centerX","centerY","_body","_createBody","_dx","_dxAtPause","_dy","_dyAtPause","_isChangingDirection","_directionMap","Map","length","i","push","getHeadPosition","getCurrentDirection","key","get","move","growing","_advanceHead","_advanceTail","unshift","pop","teleportHead","newPosition","callback","segment","index","pause","unpause","didEat","equip","didCollide","slice","some","log","hitLeftWall","hitRightWall","hitTopWall","hitBottomWall","changeDirection","newDirection","getDirection","currentDirection","_getCurrentDirection","dir2","dir1","_setNewDirection","magnitude","normalizeDirection","SPACE_KEY","LEFT_KEY","RIGHT_KEY","UP_KEY","DOWN_KEY","motionPermissionState","InputHandler","game","_game","_touchStart","_touchEnd","_boundMethods","_bindMethods","_initialOrientation","_lastOrientation","_lastOrientationUpdateTime","_sensitivityMultiplier","handleKeyInput","_handleKeyInput","bind","handleDeviceMovement","_handleDeviceMovement","handleVisibilityChange","_handleVisibilityChange","handlePauseClick","_handlePauseClick","requestDeviceOrientation","_requestDeviceOrientation","handleTouchStart","_handleTouchStart","handleTouchEnd","_handleTouchEnd","handleRestart","_handleRestart","manageGameControls","shouldAdd","_manageKeyboardControls","_manageMotionControls","_manageTouchControls","_manageClickControls","_manageVisibilityControl","manageRestartControls","action","motionControl","active","removeEventListener","DeviceOrientationEvent","_listenToDeviceOrientation","requestPermission","_activateMotionControl","_createMotionRequestButton","addEventListener","state","paused","togglePause","event","commandFn","code","_deactivateMotionControl","KeyboardEvent","restart","Date","now","updateMotionControl","hidden","preventDefault","firstTouch","changedTouches","screenX","screenY","_handleSwipeGesture","verticalSwipe","ended","catch","finally","activateMotionControl","deactivateMotionControl","_debugMotionControl","motionControlActive","deviceOrientation","isChangingDirection","snakeDirection","_simulateDeviceOrientationRequestPermission","Promise","resolve","defineProperty","prototype","value","withStraddle","cb","offset","translate","filter","border","outline","boxShadow","transition","useExclamation","iconSize","iconPadding","String","fromCharCode","lineCap","shadowBlur","shadowColor","strokeStyle","strokeRect","toString","strokeText","renderGame","renderGameOver","defaultCanvas","drawGame","drawScore","drawHighScore","highScore","drawItem","drawSnake","drawGameOver","createRenderFunctions","GameState","_paused","_ended","_score","_highScore","_getItemSafely","_speed","speed","updateScore","increment","updateHighScore","_setItemSafely","clearHighScore","setSpeed","isNaN","endGame","defaultValue","localStorage","getItem","JSON","parse","warn","setItem","stringify","CANVAS_ID","CONTROL_PANEL_ID","MOTION_INDICATOR_ID","motionIndicatorVisible","Game","input","_lastUpdateTimestamp","indicatorVisible","handleClearHighScore","_handleClearHighScore","handleToggleMotionIndicator","_handleToggleMotionIndicator","_initializeUI","run","_shouldUpdateFrame","_updateFrame","requestAnimationFrame","t","_removeEventListeners","runGame","motionDirection","motionSensitivity","motionIndicator","_advanceSnake","uiContainer","UI_CONTAINER_ID","didEatBeforeMove","toUpperCase","_generateNewItem","_maybeRegenerateItem","_checkCollision","_end","itemClass","_clearHighScore","oldHighScore","_setupMotionIndicator","_setupMotionToggleButton","_setupClearHighScoreButton","motionIndicatorDiv","clearButton","stopPropagation","ctrl_panel","_initBoard"],"mappings":"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"}