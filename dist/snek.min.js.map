{"version":3,"file":"snek.min.js","sources":["../src/js/config.js","../src/js/board.js","../src/js/error.js","../src/js/item.js","../src/js/direction.js","../src/js/snake.js","../src/js/game/input.js","../src/js/canvas.js","../src/js/game/render.js","../src/js/game/state.js","../src/js/game/game.js","../src/js/main.js"],"sourcesContent":["export const GAME_CONFIG = {\r\n    BOARD: {\r\n        CTRL_PANEL_HEIGHT: 50,  // pixels\r\n        MARGIN_SIZE: 20,  // pixels\r\n        NUM_STEPS_ACROSS_CANVAS: 30,\r\n        DEFAULT_BACKGROUND_COLOR: 'white',\r\n        DEFAULT_BORDER_COLOR: 'darkgreen',\r\n        TELEPORT_BORDER_COLOR: 'blue',\r\n        TELEPORT_BACKGROUND_COLOR: '#e2f1fa',  // a light blue\r\n        FILTERS: {\r\n            NONE: 'none',\r\n            PAUSE: 'contrast(1.4) sepia(1)',\r\n            ENDGAME: 'grayscale(0.8) blur(0.5px)',\r\n        },\r\n    },\r\n\r\n    SNAKE: {\r\n        INITIAL_LENGTH: 5,\r\n        DEFAULT_COLOR: 'lightgreen',\r\n        DEFAULT_BORDER_COLOR: 'darkgreen',\r\n        PHASE_BORDER_COLOR: 'violet',\r\n    },\r\n\r\n    ITEM: {\r\n        FOOD_COLOR: 'red',\r\n        FOOD_BORDER_COLOR: 'darkred',\r\n        PHASE_COLOR: 'orchid',\r\n        PHASE_BORDER_COLOR: 'violet',\r\n        TELEPORT_COLOR: 'blue',\r\n        TELEPORT_BORDER_COLOR: 'darkblue',\r\n        PHASE_SCORE_THRESHOLD: 150,\r\n        TELEPORT_SCORE_THRESHOLD: 50,\r\n        BASE_PHASE_PROBABILITY: 0.1,\r\n        BASE_TELEPORT_PROBABILITY: 0.1,\r\n        BASE_VOLATILE_FOOD_PROBABILITY: 0.01,\r\n    },\r\n\r\n    GAME: {\r\n        SCORE_INCREMENT: 10,\r\n        SCORE_THRESHOLD_FOR_VOLATILE_FOOD: 100,\r\n    },\r\n\r\n    INPUT: {\r\n        GAME_SPEED_MS__ARROW: 100,\r\n        GAME_SPEED_MS__MOTION: 125,     // slow down game since harder with motion controls\r\n        SWIPE_SENSITIVITY: 10,          // delta of pixels needed to consider touch mvmt a 'swipe'\r\n        MOTION_SENSITIVITY: 15,         // degree of motion needed to consider a device mvmt as intentional\r\n        MOTION_THROTTLE_TIME_MS: 100,   // min time between motion control updates to prevent over-sensitivity\r\n    },\r\n\r\n    CANVAS: {\r\n        GAME_TEXT_COLOR: 'gray',\r\n        HIGH_SCORE_TEXT_COLOR: 'goldenrod',\r\n        PAUSE_BTN_COLOR: 'darkkhaki',\r\n        EXCLAMATION_BTN_COLOR: 'darkkhaki',\r\n        GAME_TEXT_FONT_FAMILY: '\"Saira\", serif',\r\n        GAME_TEXT_FONT_SIZE: 50,\r\n    },\r\n\r\n    STATE: {\r\n        LOCAL_STORAGE_KEY_HIGH_SCORE: 'highScore',\r\n        LOCAL_STORAGE_KEY_GAME_SPEED: 'gameSpeed',\r\n    },\r\n\r\n    ERROR: {\r\n        // ERROR_MESSAGE_DURATION: 5000,\r\n        MESSAGE_FONT: '20px Arial',\r\n        MESSAGE_COLOR: 'red',\r\n        MESSAGE_BACKGROUND: 'rgba(0, 0, 0, 0.7)',\r\n    },\r\n};\r\n","import { GAME_CONFIG } from './config';\r\n\r\nconst { BOARD } = GAME_CONFIG;\r\n\r\nconst MOTION_REQUEST_BUTTON_ID = 'motionRequest';\r\n\r\n/**\r\n * Represents the game board.\r\n */\r\nexport class Board {\r\n    /**\r\n     * @param {HTMLCanvasElement} canvas - canvas element for the game\r\n     * @param {HTMLElement | null} ctrlPanel - control panel element\r\n     */\r\n    constructor(canvas, ctrlPanel) {\r\n        this._canvas = canvas;\r\n        this._ctrlPanel = ctrlPanel;\r\n\r\n        // 2d drawing context\r\n        if (!(this.ctx = this._canvas.getContext('2d'))) {\r\n            throw new Error('2d context not supported or canvas already initialized');\r\n        }\r\n\r\n        this._boardSize = this._calculateBoardSize();\r\n\r\n        // handle rendering difference between a standard display vs a HiDPI or Retina display\r\n        this._ratio = window.devicePixelRatio || 1;\r\n\r\n        this._sizeCanvas();\r\n        this._sizeControlPanel();\r\n\r\n        this._width = canvas.width;\r\n        this._height = canvas.height;\r\n        this._blockSize = canvas.width / BOARD.NUM_STEPS_ACROSS_CANVAS;\r\n\r\n        this._activeFilter = BOARD.FILTERS.NONE;\r\n        this._color = BOARD.DEFAULT_BACKGROUND_COLOR;\r\n        this._borderColor = BOARD.DEFAULT_BORDER_COLOR;\r\n        this._isGlowing = false;\r\n\r\n        this.resetFilter();\r\n\r\n        // console.log({\r\n        //     ratio: this._ratio, 'canvas.style.width': canvas.style.width,\r\n        //     'canvas.style.height': canvas.style.height, 'canvas.width': canvas.width,\r\n        //     'canvas.height': canvas.height, block_size: this._blockSize\r\n        // })\r\n    }\r\n\r\n    /**\r\n     * @returns {HTMLCanvasElement}\r\n     */\r\n    get canvas() {\r\n        return this._canvas;\r\n    }\r\n\r\n    /**\r\n     * @returns {string}\r\n     */\r\n    get color() {\r\n        return this._color;\r\n    }\r\n\r\n    /**\r\n     * @returns {string}\r\n     */\r\n    get borderColor() {\r\n        return this._borderColor;\r\n    }\r\n\r\n    /**\r\n     * @returns {boolean}\r\n     */\r\n    get isGlowing() {\r\n        return this._isGlowing;\r\n    }\r\n\r\n    /**\r\n     * @returns {string}\r\n     */\r\n    get activeFilter() {\r\n        return this._activeFilter;\r\n    }\r\n\r\n    /**\r\n     * @returns {number}\r\n     */\r\n    get width() {\r\n        return this._width;\r\n    }\r\n\r\n    /**\r\n     * @returns {number}\r\n     */\r\n    get height() {\r\n        return this._height;\r\n    }\r\n\r\n    /**\r\n     * @returns {number}\r\n     */\r\n    get blockSize() {\r\n        return this._blockSize;\r\n    }\r\n\r\n    /**\r\n     * @returns {number}\r\n     */\r\n    get ratio() {\r\n        return this._ratio;\r\n    }\r\n\r\n    /**\r\n     * Resets the board filter to default.\r\n     */\r\n    resetFilter() {\r\n        this._activeFilter = BOARD.FILTERS.NONE;\r\n    }\r\n\r\n    /**\r\n     * Sets the board filter for the end game state.\r\n     */\r\n    setEndGameFilter() {\r\n        this._activeFilter = BOARD.FILTERS.ENDGAME;\r\n    }\r\n\r\n    /**\r\n     * Sets the board filter for the paused game state.\r\n     */\r\n    setPauseGameFilter() {\r\n        this._activeFilter = BOARD.FILTERS.PAUSE;\r\n    }\r\n\r\n    /**\r\n     * Enters fullscreen mode.\r\n     */\r\n    enterFullScreen() {\r\n        // switch to full screen\r\n        this._canvas.requestFullscreen().then(function () {\r\n            try {\r\n                // lock portrait orientation when going full screen\r\n                // @ts-ignore\r\n                screen.lockOrientationUniversal = screen.lockOrientation ||\r\n                    // @ts-ignore\r\n                    screen.mozLockOrientation ||\r\n                    // @ts-ignore\r\n                    screen.msLockOrientation;\r\n                // @ts-ignore\r\n                screen.lockOrientationUniversal('portrait-primary');\r\n            } catch (e) {\r\n                // console.log(e);\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Exits fullscreen mode.\r\n     */\r\n    exitFullScreen() {\r\n        document.exitFullscreen();\r\n    }\r\n\r\n    /**\r\n     * Creates a button in control panel to request motion control permission.\r\n     * @returns {HTMLButtonElement | null} created button, or null if control panel does not exist\r\n     */\r\n    createMotionRequestBtn() {\r\n        if (!this._ctrlPanel) return null;\r\n\r\n        let btn = document.createElement('button');\r\n        btn.innerHTML = 'Allow Motion Control';\r\n        btn.setAttribute('id', MOTION_REQUEST_BUTTON_ID);\r\n        btn.type = 'button';\r\n        this._ctrlPanel.appendChild(btn);\r\n        return btn;\r\n    }\r\n\r\n    /**\r\n     * Gets the motion control request button.\r\n     */\r\n    getMotionRequestBtn() {\r\n        return document.getElementById(MOTION_REQUEST_BUTTON_ID);\r\n    }\r\n\r\n    /**\r\n     * Removes the motion control request button.\r\n     */\r\n    removeMotionRequestBtn() {\r\n        let btn = this.getMotionRequestBtn();\r\n        btn?.parentNode?.removeChild(btn);\r\n    }\r\n\r\n    /**\r\n     * Sets the glow effect on the board.\r\n     * @param {boolean} shouldGlow - whether the board should glow\r\n     */\r\n    setGlow(shouldGlow) {\r\n        if (shouldGlow === this.isGlowing) return;\r\n\r\n        this._isGlowing = shouldGlow;\r\n\r\n        if (shouldGlow) {\r\n            // note: since canvas border doesn't show in fullscreen mode, we tint the background too\r\n            this._color = BOARD.TELEPORT_BACKGROUND_COLOR;\r\n            this._borderColor = BOARD.TELEPORT_BORDER_COLOR;\r\n        } else {\r\n            this._color = BOARD.DEFAULT_BACKGROUND_COLOR;\r\n            this._borderColor = BOARD.DEFAULT_BORDER_COLOR;\r\n        }\r\n\r\n        // console.log(`[board] shouldGlow: ${shouldGlow}; borderColor: ${this.borderColor}; isGlowing: ${this.isGlowing}`);\r\n    }\r\n\r\n    /**\r\n     * Checks if the game needs permission for motion control.\r\n     * @returns {boolean} true if permission is needed; false otherwise\r\n     */\r\n    needsPermission() {\r\n        return document.getElementById(MOTION_REQUEST_BUTTON_ID) !== null;\r\n    }\r\n\r\n    /**\r\n     * Calculates the size of the game board.\r\n     * @returns {number} The calculated board size.\r\n     * @private\r\n     */\r\n    _calculateBoardSize() {\r\n        // calculate a square board size based on window dimensions and total # of steps across the canvas\r\n        const availableSpace = Math.min(window.innerWidth, window.innerHeight) - BOARD.CTRL_PANEL_HEIGHT;\r\n        const gridBlockSize = availableSpace / BOARD.NUM_STEPS_ACROSS_CANVAS;  // find closest number divisible by steps\r\n        const boardSize = Math.floor(gridBlockSize) * BOARD.NUM_STEPS_ACROSS_CANVAS - BOARD.MARGIN_SIZE;\r\n\r\n        // TODO: could implement like below instead - if willing to implement resizing\r\n        // const maxWidth = window.innerWidth - MARGIN_SIZE;\r\n        // const maxHeight = window.innerHeight - CTRL_PANEL_HEIGHT - MARGIN_SIZE;\r\n        // const boardSize = Math.min(maxWidth, maxHeight);\r\n\r\n        return boardSize;\r\n    }\r\n\r\n    /**\r\n     * Sets the size of the canvas.\r\n     * @private\r\n     */\r\n    _sizeCanvas() {\r\n        this._canvas.style.width = this._boardSize + 'px';\r\n        this._canvas.style.height = this._boardSize + 'px';\r\n        this._canvas.width = this._boardSize * this._ratio;\r\n        this._canvas.height = this._canvas.width;\r\n    }\r\n\r\n    /**\r\n     * Sets the size of the control panel.\r\n     * @private\r\n     */\r\n    _sizeControlPanel() {\r\n        if (!this._ctrlPanel) return;\r\n        this._ctrlPanel.style.width = this._boardSize + 'px';\r\n        this._ctrlPanel.style.height = BOARD.CTRL_PANEL_HEIGHT + 'px';\r\n    }\r\n}\r\n","import { GAME_CONFIG } from './config';\r\n\r\nconst { ERROR } = GAME_CONFIG;\r\n\r\n/**\r\n * Displays an error message on the screen.\r\n * @param {string} message - error message to display\r\n * @param {HTMLCanvasElement | HTMLElement | null} canvas - game canvas (if available)\r\n */\r\nexport function displayErrorMessage(message, canvas = null) {\r\n    if (canvas && canvas instanceof HTMLCanvasElement) {\r\n        displayErrorOnCanvas(message, canvas);\r\n    } else {\r\n        displayErrorInDOM(message);\r\n    }\r\n}\r\n\r\n/**\r\n * Displays an error message on the canvas.\r\n * @param {string} message - error message to display\r\n * @param {HTMLCanvasElement} canvas - game canvas\r\n * @private\r\n */\r\nfunction displayErrorOnCanvas(message, canvas) {\r\n    const ctx = canvas.getContext('2d');\r\n    if (!ctx) {\r\n        console.error('unable to get 2D context from canvas');\r\n        displayErrorInDOM(message);\r\n        return;\r\n    }\r\n\r\n    // save the current canvas state\r\n    ctx.save();\r\n\r\n    // set up the error message style\r\n    ctx.font = ERROR.MESSAGE_FONT;\r\n    ctx.fillStyle = ERROR.MESSAGE_BACKGROUND;\r\n\r\n    // calculate message width and position\r\n    const messageWidth = ctx.measureText(message).width + 20; // Add some padding\r\n    const messageHeight = 30;\r\n    const messageX = (canvas.width - messageWidth) / 2;\r\n    const messageY = canvas.height / 2 - messageHeight / 2;\r\n\r\n    // draw the background\r\n    ctx.fillRect(messageX, messageY, messageWidth, messageHeight);\r\n\r\n    // draw the error message\r\n    ctx.fillStyle = ERROR.MESSAGE_COLOR;\r\n    ctx.textAlign = 'center';\r\n    ctx.textBaseline = 'middle';\r\n    ctx.fillText(message, canvas.width / 2, canvas.height / 2);\r\n\r\n    // restore the canvas state\r\n    ctx.restore();\r\n\r\n    // remove the error message after a set duration\r\n    // setTimeout(() => {\r\n    //     ctx.clearRect(0, 0, canvas.width, canvas.height);\r\n    //     // note: not redrawing the game here as we might not have a valid game state\r\n    // }, ERROR_MESSAGE_DURATION);\r\n}\r\n\r\n/**\r\n * Displays an error message in the DOM.\r\n * @param {string} message - error message to display\r\n * @private\r\n */\r\nfunction displayErrorInDOM(message) {\r\n    const errorDiv = document.createElement('div');\r\n    errorDiv.style.position = 'fixed';\r\n    errorDiv.style.top = '50%';\r\n    errorDiv.style.left = '50%';\r\n    errorDiv.style.transform = 'translate(-50%, -50%)';\r\n    errorDiv.style.backgroundColor = ERROR.MESSAGE_BACKGROUND;\r\n    errorDiv.style.color = ERROR.MESSAGE_COLOR;\r\n    errorDiv.style.padding = '15px';\r\n    errorDiv.style.borderRadius = '5px';\r\n    errorDiv.style.zIndex = '1000';\r\n\r\n    // preserve line breaks in multi-line messages\r\n    errorDiv.style.whiteSpace = 'pre-wrap';\r\n\r\n    // for long messages, add a max-width and use word-wrapping\r\n    errorDiv.style.maxWidth = '80%';\r\n    errorDiv.style.overflowWrap = 'break-word';\r\n\r\n    errorDiv.textContent = message;\r\n\r\n    document.body.appendChild(errorDiv);\r\n\r\n    // setTimeout(() => {\r\n    //     document.body.removeChild(errorDiv);\r\n    // }, ERROR_MESSAGE_DURATION);\r\n}\r\n","import { GAME_CONFIG } from './config';\r\n\r\nconst { ITEM } = GAME_CONFIG;\r\n\r\nexport const PHASE_CLASSNAME = 'Phase';\r\nexport const TELEPORT_CLASSNAME = 'Teleport';\r\n\r\n/**\r\n * Represents an item that can be consumed by snek in the game.\r\n */\r\nexport class Item {\r\n    /**\r\n     * @param {import('./board').Board} board - game board\r\n     * @param {import('./snake').Snake} snake - snek object\r\n     */\r\n    constructor(board, snake) {\r\n        this._x = Number.MIN_SAFE_INTEGER, this._y = Number.MIN_SAFE_INTEGER;\r\n        this._generate(board, snake);\r\n    }\r\n\r\n    /**\r\n     * Gets the x-coordinate of the item.\r\n     * @returns {number} x-coordinate\r\n     */\r\n    get x() {\r\n        return this._x;\r\n    }\r\n\r\n    /**\r\n     * Gets the y-coordinate of the item.\r\n     * @returns {number} y-coordinate\r\n     */\r\n    get y() {\r\n        return this._y;\r\n    }\r\n\r\n    /**\r\n     * Gets the type of the item.\r\n     * @returns {string} item type\r\n     */\r\n    get type() { return 'UNKNOWN_ITEM' }\r\n\r\n    /**\r\n     * Gets the fill color of the item.\r\n     * @returns {string} fill color\r\n     */\r\n    get fillColor() { return '' }\r\n\r\n    /**\r\n     * Gets the border color of the item.\r\n     * @returns {string} border color\r\n     */\r\n    get borderColor() { return '' }\r\n\r\n    /**\r\n     * Generates a new position for the item.\r\n     * @param {import('./board').Board} board - game board\r\n     * @param {import('./snake').Snake} snake - snek object\r\n     * @private\r\n     */\r\n    _generate(board, snake) {\r\n        this._x = this._randomBlock(0, board.width - board.blockSize, board.blockSize);\r\n        this._y = this._randomBlock(0, board.height - board.blockSize, board.blockSize);\r\n\r\n        snake.forEachSegment((/** @type {{ x: number; y: number; }} @returns {void} */ snakeSegment) => {\r\n            const itemIsOnSnake = snakeSegment.x == this.x && snakeSegment.y == this.y\r\n            if (itemIsOnSnake) this._generate(board, snake);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Generates a random block position.\r\n     * @param {number} min - minimum value\r\n     * @param {number} max - maximum value\r\n     * @param {number} blockSize - size of each block\r\n     * @returns {number} random block position\r\n     * @private\r\n     */\r\n    _randomBlock(min, max, blockSize) {\r\n        // note: round to snap item placement to grid, as defined by blockSize\r\n        return Math.round((Math.random() * (max-min) + min) / blockSize) * blockSize;\r\n    }\r\n}\r\n\r\n/**\r\n * Represents a food item in the game.\r\n * Food is the basic item that snek consumes to grow and increase the player's score.\r\n * @extends Item\r\n */\r\nexport class Food extends Item {\r\n\r\n    /**\r\n     * Gets the food type.\r\n     * @returns {string} food type\r\n     */\r\n    get type() { return 'FOOD' }\r\n\r\n    /**\r\n     * Gets the fill color of the food.\r\n     * @returns {string} fill color\r\n     */\r\n    get fillColor() { return ITEM.FOOD_COLOR }\r\n\r\n    /**\r\n     * Gets the border color of the food.\r\n     * @returns {string} border color\r\n     */\r\n    get borderColor() { return ITEM.FOOD_BORDER_COLOR }\r\n}\r\n\r\n/**\r\n * Represents a teleport item in the game.\r\n * Teleport is a power-up that allows snek to pass through the walls of the game board.\r\n * When consumed, it gives snek the ability to \"wrap around\" the game board once.\r\n * @extends Item\r\n */\r\nexport class Teleport extends Item {\r\n\r\n    /**\r\n     * Gets the teleport type.\r\n     * @returns {string} teleport type\r\n     */\r\n    get type() { return 'TELEPORT' }\r\n\r\n    /**\r\n     * Gets the fill color of the teleport item.\r\n     * @returns {string} fill color\r\n     */\r\n    get fillColor() { return ITEM.TELEPORT_COLOR }\r\n\r\n    /**\r\n     * Gets the border color of the teleport item.\r\n     * @returns {string} border color\r\n     */\r\n    get borderColor() { return ITEM.TELEPORT_BORDER_COLOR }\r\n}\r\n\r\n/**\r\n * Represents a phase item in the game.\r\n * Phase is a power-up that allows snek the ability to pass through its own body once.\r\n * @extends Item\r\n */\r\nexport class Phase extends Item {\r\n\r\n    /**\r\n     * Gets the phase type.\r\n     * @returns {string} phase type\r\n     */\r\n    get type() { return 'PHASE' }\r\n\r\n    /**\r\n     * Gets the fill color of the phase item.\r\n     * @returns {string} fill color\r\n     */\r\n    get fillColor() { return ITEM.PHASE_COLOR }\r\n\r\n    /**\r\n     * Gets the border color of the phase item.\r\n     * @returns {string} border color\r\n     */\r\n    get borderColor() { return ITEM.PHASE_BORDER_COLOR }\r\n}\r\n\r\nconst ITEM_TYPES = {\r\n    none: null,\r\n    food: Food,\r\n    teleport: Teleport,\r\n    phase: Phase\r\n};\r\n\r\n/**\r\n * Options for item selection.\r\n * @typedef {Object} ItemSelectionOptions\r\n * @property {boolean} [alwaysReturnItem=false] - If true, always returns an item (never null)\r\n * @property {boolean} [reducePowerUpProbability=false] - If true, reduces the probability of power-ups\r\n */\r\n\r\n/**\r\n * Randomizes the selection of an item type based on game conditions.\r\n * @param {number} score - current game score\r\n * @param {{ [x: string]: boolean; }} powerUps - available power-ups and whether eqipped\r\n * @param {ItemSelectionOptions} [options={}] - options for item selection\r\n * @returns {(new (board: import('./board').Board, item: import('./snake').Snake) => Item)} selected item class or null\r\n */\r\nexport function selectRandomItem(score, powerUps, options = {}) {\r\n    const { alwaysReturnItem = false, reducePowerUpProbability = false } = options;\r\n\r\n    const itemChances = calculateItemProbabilities(score, powerUps, alwaysReturnItem, reducePowerUpProbability);\r\n\r\n    // console.log(itemChances);\r\n\r\n    const selectedItemType = pickItem(itemChances);\r\n    return ITEM_TYPES[selectedItemType];\r\n}\r\n\r\n/**\r\n * Picks an item based on a weighted random selection algorithm.\r\n * @param {{ [x: string]: any; }} chances - chances for each item\r\n * @returns {string} selected item key\r\n */\r\nfunction pickItem(chances) {\r\n    const random = Math.random();  // random value to use for selection\r\n    let cumulativeProbability = 0;\r\n\r\n    for (const [item, probability] of Object.entries(chances)) {\r\n        cumulativeProbability += probability;\r\n        if (random <= cumulativeProbability) {\r\n            return item;\r\n        }\r\n    }\r\n\r\n    // this should never happen if probabilities sum to 1\r\n    throw new Error('item selection failed');\r\n}\r\n\r\n/**\r\n * Calculates probability of generation for each item type.\r\n * Provides ability to balance the game by making power-ups less frequent in certain situations.\r\n * @param {number} score - current game score\r\n * @param {{ [x: string]: boolean }} powerUps - current power-ups\r\n * @param {boolean} alwaysReturnItem - whether to always return an item\r\n * @param {boolean} reducePowerUpProbability - whether to reduce the probability of power-ups\r\n * @returns {{ [x: string]: number }} probabilities for each item type\r\n */\r\nfunction calculateItemProbabilities(score, powerUps, alwaysReturnItem, reducePowerUpProbability) {\r\n    // note: a power-up always drops AT its score threshold; afterwards drops get random\r\n    const teleportProb = calculateTeleportProbability(score, powerUps, alwaysReturnItem, reducePowerUpProbability);\r\n    const phaseProb = calculatePhaseProbability(score, powerUps, alwaysReturnItem, reducePowerUpProbability);\r\n\r\n    let foodProb, noItemProb;\r\n    if (alwaysReturnItem) {\r\n        foodProb = 1 - teleportProb - phaseProb;\r\n        noItemProb = 0;\r\n    } else {\r\n        foodProb = ITEM.BASE_VOLATILE_FOOD_PROBABILITY;\r\n        noItemProb = 1 - teleportProb - phaseProb - foodProb;\r\n    }\r\n\r\n    const probabilities = {\r\n        none: noItemProb,\r\n        food: foodProb,\r\n        teleport: teleportProb,\r\n        phase: phaseProb,\r\n    };\r\n\r\n    const totalProb = Object.values(probabilities).reduce((sum, prob) => sum + prob, 0);\r\n    if (Math.abs(totalProb - 1) > 1e-10) {  // allow for small floating-point errors\r\n        throw new Error(`Item probabilities must sum to 1. Current sum: ${totalProb}`);\r\n    }\r\n\r\n    return probabilities;\r\n}\r\n\r\n/**\r\n * Calculates the probability of generating a Teleport item.\r\n * @param {number} score - current game score\r\n * @param {{ [x: string]: boolean }} powerUps - current power-ups\r\n * @param {boolean} alwaysReturnItem - whether to always return an item\r\n * @param {boolean} reducePowerUpProbability - whether to reduce the probability of power-ups\r\n * @returns {number} probability of generating a Teleport item\r\n */\r\nfunction calculateTeleportProbability(score, powerUps, alwaysReturnItem, reducePowerUpProbability) {\r\n    if (score === ITEM.TELEPORT_SCORE_THRESHOLD && alwaysReturnItem) return 1;\r\n    if (score > ITEM.TELEPORT_SCORE_THRESHOLD && !powerUps[TELEPORT_CLASSNAME]) {\r\n        return reducePowerUpProbability ? ITEM.BASE_TELEPORT_PROBABILITY / 10 : ITEM.BASE_TELEPORT_PROBABILITY;\r\n    }\r\n    return 0;\r\n}\r\n\r\n/**\r\n * Calculates the probability of generating a Phase item.\r\n * @param {number} score - current game score\r\n * @param {{ [x: string]: boolean }} powerUps - current power-ups\r\n * @param {boolean} alwaysReturnItem - whether to always return an item\r\n * @param {boolean} reducePowerUpProbability - whether to reduce the probability of power-ups\r\n * @returns {number} probability of generating a Phase item\r\n */\r\nfunction calculatePhaseProbability(score, powerUps, alwaysReturnItem, reducePowerUpProbability) {\r\n    if (score === ITEM.PHASE_SCORE_THRESHOLD && alwaysReturnItem) return 1;\r\n    if (score > ITEM.PHASE_SCORE_THRESHOLD && !powerUps[PHASE_CLASSNAME]) {\r\n        return reducePowerUpProbability ? ITEM.BASE_PHASE_PROBABILITY / 10 : ITEM.BASE_PHASE_PROBABILITY;\r\n    }\r\n    return 0;\r\n}\r\n","export const DIRECTION_LEFT = 'left';\r\nexport const DIRECTION_RIGHT = 'right';\r\nexport const DIRECTION_UP = 'up';\r\nexport const DIRECTION_DOWN = 'down';\r\n\r\n/**\r\n * @typedef {Object} Direction\r\n * @property {number} dx - change in x direction\r\n * @property {number} dy - change in y direction\r\n */\r\n\r\n/**\r\n * Object mapping direction strings to their corresponding Direction objects.\r\n * @type {Object.<string, Direction>}\r\n */\r\nexport const DIRECTIONS = {\r\n    [DIRECTION_LEFT]:  { dx: -1, dy: 0 },\r\n    [DIRECTION_RIGHT]: { dx: 1,  dy: 0 },\r\n    [DIRECTION_UP]:    { dx: 0,  dy: -1 },\r\n    [DIRECTION_DOWN]:  { dx: 0,  dy: 1 },\r\n};\r\n\r\n/**\r\n * Gets the Direction object for a given direction string.\r\n * @param {string} direction - direction string\r\n * @returns {Direction | null} Direction object or null if not found\r\n */\r\nexport function getDirection(direction) {\r\n    return DIRECTIONS[direction.toLowerCase()] || null;\r\n}\r\n\r\n/**\r\n * Checks if two directions are opposite to each other.\r\n * @param {Direction} dir1 - first direction\r\n * @param {Direction} dir2 - second direction\r\n * @returns {boolean} true if the directions are opposite; false otherwise\r\n */\r\nexport function isOppositeDirection(dir1, dir2) {\r\n    return dir1.dx === -dir2.dx && dir1.dy === -dir2.dy;\r\n}\r\n\r\n/**\r\n * Normalizes a direction vector to have a magnitude of 1.\r\n * @param {number} dx - x component of the direction\r\n * @param {number} dy - y component of the direction\r\n * @returns {Direction} normalized direction\r\n */\r\nexport function normalizeDirection(dx, dy) {\r\n    const magnitude = Math.max(Math.abs(dx), Math.abs(dy));\r\n    if (magnitude === 0) {\r\n        return { dx: 0, dy: 0 };\r\n    }\r\n    return { dx: dx / magnitude, dy: dy / magnitude };\r\n}\r\n","import { GAME_CONFIG } from './config';\r\nimport { DIRECTION_DOWN, DIRECTION_LEFT, DIRECTION_RIGHT, DIRECTION_UP, getDirection, isOppositeDirection, normalizeDirection } from './direction';\r\nimport { PHASE_CLASSNAME, Phase, TELEPORT_CLASSNAME, Teleport } from './item';\r\n\r\nconst { SNAKE } = GAME_CONFIG;\r\n\r\n/**\r\n * Represents snek in the game.\r\n */\r\nexport class Snake {\r\n\r\n    /**\r\n     * @param {number} boardWidth - width of the game board\r\n     * @param {number} boardHeight - height of the game board\r\n     * @param {number} blockSize - size of each block on the board\r\n     */\r\n    constructor(boardWidth, boardHeight, blockSize) {\r\n        this._blockSize = blockSize;\r\n\r\n        // calculate initial position (center of the board)\r\n        const centerX = Math.floor(boardWidth / (2 * blockSize)) * blockSize;\r\n        const centerY = Math.floor(boardHeight / (2 * blockSize)) * blockSize;\r\n\r\n        this._body = this._createBody(centerX, centerY, SNAKE.INITIAL_LENGTH);\r\n\r\n        // set initial velocity\r\n        this._dx = this._dxAtPause = blockSize;\r\n        this._dy = this._dyAtPause = 0;\r\n        this._isChangingDirection = false;\r\n\r\n        // set initial appearance\r\n        this._color = SNAKE.DEFAULT_COLOR;\r\n        this._borderColor = SNAKE.DEFAULT_BORDER_COLOR;\r\n        this._isGlowing = false;\r\n\r\n        this.powerUps = { [TELEPORT_CLASSNAME]: false, [PHASE_CLASSNAME]: false };\r\n\r\n        this._directionMap = new Map([\r\n            [`${blockSize},0`, DIRECTION_RIGHT],\r\n            [`${-blockSize},0`, DIRECTION_LEFT],\r\n            [`0,${-blockSize}`, DIRECTION_UP],\r\n            [`0,${blockSize}`, DIRECTION_DOWN]\r\n        ]);\r\n    }\r\n\r\n    /**\r\n     * Creates the body of snek.\r\n     * @param {number} centerX - x-coordinate of the center of the board\r\n     * @param {number} centerY - y-coordinate of the center of the board\r\n     * @param {number} length - number of parts composing snek body\r\n     * @returns {{ x: number; y: number; }[]} created snek body\r\n     * @private\r\n     */\r\n    _createBody(centerX, centerY, length) {\r\n        const body = [];\r\n        for (let i = 0; i < length; i++) {\r\n            body.push({\r\n                x: centerX - i * this._blockSize,\r\n                y: centerY\r\n            });\r\n        }\r\n        return body;\r\n    }\r\n\r\n    /**\r\n     * Gets snek's fill color.\r\n     * @returns {string} fill color\r\n     */\r\n    get color() {\r\n        return this._color;\r\n    }\r\n\r\n    /**\r\n     * Gets snek's border color.\r\n     * @returns {string} border color\r\n     */\r\n    get borderColor() {\r\n        return this._borderColor;\r\n    }\r\n\r\n    /**\r\n     * Gets whether snek is glowing.\r\n     * @returns {boolean} true if snek is glowing; false otherwise\r\n     */\r\n    get isGlowing() {\r\n        return this._isGlowing;\r\n    }\r\n\r\n    /**\r\n     * Gets the position of snek's head.\r\n     * @returns {{ x: number; y: number }} head position\r\n     */\r\n    getHeadPosition() {\r\n        return { ...this._body[0] };\r\n    }\r\n\r\n    /**\r\n     * Gets the current direction of snek.\r\n     * @returns {string} current direction ('left', 'right', 'up', or 'down')\r\n     */\r\n    getCurrentDirection() {\r\n        const key = `${this._dx},${this._dy}`;\r\n        return this._directionMap.get(key) || 'unknown';\r\n    }\r\n\r\n    /**\r\n     * Moves snek in its current direction.\r\n     * @param {boolean} growing whether snek should grow\r\n     */\r\n    move(growing = false) {\r\n        this._advanceHead();\r\n        if (!growing) {\r\n            this._advanceTail();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Advances snek's head.\r\n     */\r\n    _advanceHead() {\r\n        // note: round to snap snek movement to grid, as defined by blockSize\r\n        const head = {\r\n            x: Math.round((this.getHeadPosition().x + this._dx) / this._blockSize) * this._blockSize,\r\n            y: Math.round((this.getHeadPosition().y + this._dy) / this._blockSize) * this._blockSize\r\n        };\r\n        this._body.unshift(head);\r\n\r\n        this._isChangingDirection = false;\r\n\r\n        // TODO: add to control panel\r\n        // console.log(`HEAD: ${head.x}, ${head.y}`);\r\n    }\r\n\r\n    /**\r\n     * Advances snek's tail (removes the last segment).\r\n     */\r\n    _advanceTail() {\r\n        this._body.pop();\r\n    }\r\n\r\n    /**\r\n     * Teleports snek's head to a new position.\r\n     * Useful for unit testing.\r\n     * @param {{ x: number; y: number }} newPosition new position for the head\r\n     */\r\n    teleportHead(newPosition) {\r\n        this._body[0] = { ...newPosition };\r\n    }\r\n\r\n    /**\r\n     * Executes a callback for each segment of snek's body.\r\n     * @param {(segment: { x: number; y: number }, index: number) => void} callback\r\n     */\r\n    forEachSegment(callback) {\r\n        this._body.forEach((segment, index) => callback({ ...segment }, index));\r\n    }\r\n\r\n    /**\r\n     * Pauses snek's movement.\r\n     */\r\n    pause() {\r\n        // save velocity at pause\r\n        this._dxAtPause = this._dx;\r\n        this._dyAtPause = this._dy;\r\n        // set velocity to 0\r\n        this._dx = this._dy = 0;\r\n    }\r\n\r\n    /**\r\n     * Resumes snek's movement after a pause.\r\n     */\r\n    unpause() {\r\n        // set velocity to state before pause\r\n        this._dx = this._dxAtPause;\r\n        this._dy = this._dyAtPause;\r\n    }\r\n\r\n    /**\r\n     * Checks if snek has eaten an item.\r\n     * @param {import('./item').Item} item - item to check\r\n     * @returns {boolean} true if snek has eaten the item; false otherwise\r\n     */\r\n    didEat(item) {\r\n        let head = this.getHeadPosition();\r\n        return head.x === item.x && head.y === item.y;\r\n    }\r\n\r\n    /**\r\n     * Equips snek with a power-up\r\n     * @param {import('./item').Item} item - power-up item to equip\r\n     */\r\n    equip(item) {\r\n        if (item instanceof Teleport) this.powerUps[TELEPORT_CLASSNAME] = true;\r\n        if (item instanceof Phase) {\r\n            this.powerUps[PHASE_CLASSNAME] = true;\r\n            this.setGlow(true);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the glow effect on snek.\r\n     * @param {boolean} shouldGlow - whether snek should glow\r\n     */\r\n    setGlow(shouldGlow) {\r\n        if (shouldGlow === this.isGlowing) return;\r\n\r\n        this._isGlowing = shouldGlow;\r\n\r\n        this._borderColor = shouldGlow ? SNAKE.PHASE_BORDER_COLOR : SNAKE.DEFAULT_BORDER_COLOR;\r\n\r\n        // console.log(`[snek] shouldGlow: ${shouldGlow}; borderColor: ${this.borderColor}; isGlowing: ${this.isGlowing}`);\r\n    }\r\n\r\n    /**\r\n     * Checks if snek has collided with itself or the board boundaries.\r\n     * @param {number} boardWidth - width of the game board\r\n     * @param {number} boardHeight - height of the game board.\r\n     * @param {number} blockSize - size of each block on the board\r\n     * @returns {boolean} true if snek has collided; false otherwise\r\n     */\r\n    didCollide(boardWidth, boardHeight, blockSize) {\r\n        let head = this.getHeadPosition();\r\n\r\n        // loop starts at index 4 because it is impossible for the first three parts to touch each other\r\n        const collidesWithSelf = this._body.slice(4).some(segment => segment.x === head.x && segment.y === head.y);\r\n        if (collidesWithSelf) {\r\n            if (this.powerUps[PHASE_CLASSNAME]) {\r\n                // if phase powerup is equipped, decrement, ignore collision, and continue game\r\n                this.powerUps[PHASE_CLASSNAME] = false;\r\n                this.setGlow(false);\r\n\r\n                console.log('snek phased!');\r\n                return false;\r\n            }\r\n            return true;\r\n        }\r\n\r\n        // check for collisions with walls\r\n        const hitLeftWall = head.x < 0;\r\n        const hitRightWall = head.x + blockSize > boardWidth;\r\n        const hitTopWall = head.y < 0;\r\n        const hitBottomWall = head.y + blockSize > boardHeight;\r\n\r\n        const hitWall = hitLeftWall || hitRightWall || hitTopWall || hitBottomWall;\r\n\r\n        if (!hitWall) { return false; }\r\n\r\n        // if teleport power is equipped, decrement, teleport, and continue game\r\n        if (this.powerUps[TELEPORT_CLASSNAME]) {\r\n            this.powerUps[TELEPORT_CLASSNAME] = false;\r\n\r\n            // teleport to opposite side of the board\r\n            if (hitLeftWall) {\r\n                this.teleportHead({x: boardWidth - blockSize, y: head.y});\r\n            } else if (hitRightWall) {\r\n                this.teleportHead({x: 0, y: head.y});\r\n            } else if (hitTopWall) {\r\n                this.teleportHead({x: head.x, y: boardHeight - blockSize});\r\n            } else if (hitBottomWall) {\r\n                this.teleportHead({x: head.x, y: 0});\r\n            }\r\n\r\n            console.log('snek teleported!');\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Changes the direction of snek.\r\n     * @param {string} direction - new direction\r\n     * @returns {boolean} true if snek direction was changed; false otherwise\r\n     */\r\n    changeDirection(direction) {\r\n        // prevent changing direction multiple times before the next move\r\n        if (this._isChangingDirection) return false;\r\n\r\n        const newDirection = getDirection(direction);\r\n        if (!newDirection) return false;\r\n\r\n        const currentDirection = this._getCurrentDirection();\r\n        // prevent snek from moving back on itself\r\n        if (isOppositeDirection(currentDirection, newDirection)) return false;\r\n\r\n        this._setNewDirection(newDirection);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Gets the current direction of snek.\r\n     * @returns {import('./direction').Direction} current direction\r\n     * @private\r\n     */\r\n    _getCurrentDirection() {\r\n        // normalize the current velocity to get direction\r\n        return normalizeDirection(this._dx, this._dy);\r\n    }\r\n\r\n    /**\r\n     * Sets a new direction for snek.\r\n     * @param {import('./direction').Direction} direction - new direction\r\n     * @private\r\n     */\r\n    _setNewDirection(direction) {\r\n        this._isChangingDirection = true;\r\n        this._dx = direction.dx * this._blockSize;\r\n        this._dy = direction.dy * this._blockSize;\r\n    }\r\n}\r\n","import { GAME_CONFIG } from '../config';\r\nimport { DIRECTION_DOWN, DIRECTION_LEFT, DIRECTION_RIGHT, DIRECTION_UP } from '../direction';\r\n\r\nconst { INPUT } = GAME_CONFIG;\r\n\r\nconst SPACE_KEY = 'Space';\r\nconst LEFT_KEY = 'ArrowLeft';\r\nconst RIGHT_KEY = 'ArrowRight';\r\nconst UP_KEY = 'ArrowUp';\r\nconst DOWN_KEY = 'ArrowDown';\r\n\r\n/**\r\n * Handles user input for the game.\r\n */\r\nexport class InputHandler {\r\n    /**\r\n     * @param {import('./game').Game} game - game instance\r\n     */\r\n    constructor(game) {\r\n        this._game = game;\r\n        this._motionAvailable = null;\r\n        this._deviceOrientation = {\r\n            beta: 0,  // rotation around x-axis (-180 to 180)\r\n            gamma: 0  // rotation around y-axis (-90 to 90)\r\n        };\r\n        this._lastOrientationUpdate = 0;\r\n        this._touchStart = { x: 0, y: 0 };\r\n        this._touchEnd = { x: 0, y: 0 };\r\n        this._boundMethods = this._bindMethods();\r\n    }\r\n\r\n    /**\r\n     * Manages all control event listeners for the game.\r\n     * @param {boolean} shouldAdd - if true, adds the event listeners; if false, removes them.\r\n     */\r\n    manageGameControls(shouldAdd) {\r\n        this._manageKeyboardControls(shouldAdd);\r\n        this._manageTouchControls(shouldAdd);\r\n        this._manageVisibilityControl(shouldAdd);\r\n        this._managePauseControl(shouldAdd);\r\n        this._manageFullscreenControl(shouldAdd);\r\n        this._manageDeviceOrientationControl(shouldAdd);\r\n    }\r\n\r\n    /**\r\n     * Manages controls for restarting the game.\r\n     * @param {boolean} shouldAdd - if true, adds the event listeners; if false, removes them.\r\n     */\r\n    manageRestartControls(shouldAdd) {\r\n        const action = shouldAdd ? 'addEventListener' : 'removeEventListener';\r\n        if (shouldAdd && !this._motionAvailable) {\r\n            // remove existing keyboard listener to avoid conflicts with new restart controls\r\n            document.removeEventListener('keydown', this._boundMethods.handleKeyInput);\r\n        }\r\n        document[action]('keydown', this._boundMethods.handleRestart);\r\n        document[action]('click', this._boundMethods.handleRestart);\r\n    }\r\n\r\n    /**\r\n     * Creates and returns an object containing all event handler methods bound to the current instance of InputHandler.\r\n     * Ensures they always have the correct `this` context when called, regardless of how they are invoked.\r\n     * @returns {Object} object containing bound method references\r\n     * @private\r\n     */\r\n    _bindMethods() {\r\n        return {\r\n            handleKeyInput: this._handleKeyInput.bind(this),\r\n            handleDeviceMovement: this._handleDeviceMovement.bind(this),\r\n            handleVisibilityChange: this._handleVisibilityChange.bind(this),\r\n            requestDeviceOrientation: this._requestDeviceOrientation.bind(this),\r\n            togglePause: this._game.togglePause.bind(this._game),\r\n            enterFullScreen: this._game.board.enterFullScreen.bind(this._game.board),\r\n            handleTouchStart: this._handleTouchStart.bind(this),\r\n            handleTouchEnd: this._handleTouchEnd.bind(this),\r\n            handleRestart: this._handleRestart.bind(this)\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Manages keyboard control event listeners for the game.\r\n     * @param {boolean} shouldAdd - if true, adds the event listeners; if false, removes them.\r\n     * @private\r\n     */\r\n    _manageKeyboardControls(shouldAdd) {\r\n        const action = shouldAdd ? 'addEventListener' : 'removeEventListener';\r\n        document[action]('keydown', this._boundMethods.handleKeyInput);\r\n    }\r\n\r\n    /**\r\n     * Manages touch control event listeners for the game.\r\n     * @param {boolean} shouldAdd - if true, adds the event listeners; if false, removes them.\r\n     * @private\r\n     */\r\n    _manageTouchControls(shouldAdd) {\r\n        const action = shouldAdd ? 'addEventListener' : 'removeEventListener';\r\n        this._game.board.canvas[action]('touchstart', this._boundMethods.handleTouchStart);\r\n        this._game.board.canvas[action]('touchend', this._boundMethods.handleTouchEnd);\r\n    }\r\n\r\n    /**\r\n     * Set up visibility change control event listeners for the game.\r\n     * @param {boolean} shouldAdd - if true, adds the event listeners; if false, removes them.\r\n     * @private\r\n     */\r\n    _manageVisibilityControl(shouldAdd) {\r\n        const action = shouldAdd ? 'addEventListener' : 'removeEventListener';\r\n        document[action]('visibilitychange', this._boundMethods.handleVisibilityChange, false);\r\n    }\r\n\r\n    /**\r\n     * Set up pause control event listeners for the game.\r\n     * @param {boolean} shouldAdd - if true, adds the event listeners; if false, removes them.\r\n     * @private\r\n     */\r\n    _managePauseControl(shouldAdd) {\r\n        const action = shouldAdd ? 'addEventListener' : 'removeEventListener';\r\n        document[action]('click', this._boundMethods.togglePause);\r\n    }\r\n\r\n    /**\r\n     * Set up fullscreen control event listeners for the game.\r\n     * @param {boolean} shouldAdd - if true, adds the event listeners; if false, removes them.\r\n     * @private\r\n     */\r\n    _manageFullscreenControl(shouldAdd) {\r\n        const action = shouldAdd ? 'addEventListener' : 'removeEventListener';\r\n        document[action]('dblclick', this._boundMethods.enterFullScreen);\r\n    }\r\n\r\n    /**\r\n     * Set up device orientation event listeners for the game, if available.\r\n     * @param {boolean} shouldAdd - if true, adds the event listeners; if false, removes them.\r\n     * @private\r\n     */\r\n    _manageDeviceOrientationControl(shouldAdd) {\r\n        const action = shouldAdd ? 'addEventListener' : 'removeEventListener';\r\n\r\n        if (typeof DeviceOrientationEvent !== 'undefined') {\r\n            if (typeof DeviceOrientationEvent.requestPermission === 'function') {\r\n                if (shouldAdd) {\r\n                    let btn = this._game.board.createMotionRequestBtn();\r\n                    if (btn) {\r\n                        btn.addEventListener('click', this._boundMethods.requestDeviceOrientation);\r\n\r\n                        // give user time to grant permission\r\n                        this._game.togglePause();\r\n                    }\r\n                } else {\r\n                    let btn = this._game.board.getMotionRequestBtn();\r\n                    if (btn) {\r\n                        btn.removeEventListener('click', this._boundMethods.requestDeviceOrientation);\r\n                    }\r\n                }\r\n            } else {\r\n                window[action]('deviceorientation', this._boundMethods.handleDeviceMovement);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Handles keyboard input.\r\n     * @param {KeyboardEvent} event - keyboard event\r\n     * @private\r\n     */\r\n    _handleKeyInput(event) {\r\n        const keyCommands = {\r\n            [LEFT_KEY]: new MoveCommand(DIRECTION_LEFT),\r\n            [RIGHT_KEY]: new MoveCommand(DIRECTION_RIGHT),\r\n            [UP_KEY]: new MoveCommand(DIRECTION_UP),\r\n            [DOWN_KEY]: new MoveCommand(DIRECTION_DOWN),\r\n            [SPACE_KEY]: new PauseCommand()\r\n        };\r\n\r\n        const command = keyCommands[event.code];\r\n        if (command) {\r\n            if (this._motionAvailable === null && !this._game.state._ended) {\r\n                console.log('key controls activated');\r\n            }\r\n\r\n            // disable motion control when keyboard is used\r\n            // (having both keyboard and motion event listeners makes the game less responsive)\r\n            this._disableMotionControl();\r\n\r\n            command.execute(this._game);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Handles restart events triggered by key press, click, or touch.\r\n     * @param {KeyboardEvent | MouseEvent | TouchEvent} ev - event object\r\n     */\r\n    _handleRestart(ev) {\r\n        if ((ev instanceof KeyboardEvent && ev.code === SPACE_KEY) ||\r\n            ev.type === 'click' ||\r\n            ev.type === 'touchend') {\r\n            this._game.restart();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Handles device motion input.\r\n     * @param {DeviceOrientationEvent} event - device orientation event\r\n     * @private\r\n     */\r\n    _handleDeviceMovement(event) {\r\n        const now = Date.now();\r\n\r\n        const currentOrientation = {\r\n            beta: event.beta || 0,\r\n            gamma: event.gamma || 0\r\n        }\r\n\r\n        // ensure we're not updating too frequently / causing jerkiness\r\n        if (now - this._lastOrientationUpdate < INPUT.MOTION_THROTTLE_TIME_MS) {\r\n            return;\r\n        }\r\n\r\n        const orientationChange = {\r\n            beta: this._deviceOrientation.beta - currentOrientation.beta,\r\n            gamma: this._deviceOrientation.gamma - currentOrientation.gamma\r\n        }\r\n\r\n        // check if this is the first significant movement detected\r\n        // used to determine when to switch from keyboard to motion controls\r\n        if (this._motionAvailable === null && this._isSignificantMotion(orientationChange)) {\r\n            this._enableMotionControl();\r\n        }\r\n\r\n        const direction = this._getDirectionFromOrientation(orientationChange);\r\n        if (direction) {\r\n            let command = new MoveCommand(direction);\r\n            command.execute(this._game);\r\n            this._lastOrientationUpdate = now;\r\n            this._deviceOrientation = currentOrientation;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Determines if a change in device orientation is significant enough to trigger a direction change.\r\n     * Filters out small, unintentional device movements so we respond only to deliberate motions.\r\n     * @param {Object} orientationChange - change in device orientation\r\n     * @param {number} orientationChange.beta - change in beta (x-axis rotation) in degrees\r\n     * @param {number} orientationChange.gamma - change in gamma (y-axis rotation) in degrees\r\n     * @returns {boolean} true if the motion is considered significant; false otherwise\r\n     * @private\r\n     */\r\n    _isSignificantMotion(orientationChange) {\r\n        return Math.abs(orientationChange.beta) > INPUT.MOTION_SENSITIVITY ||\r\n               Math.abs(orientationChange.gamma) > INPUT.MOTION_SENSITIVITY;\r\n    }\r\n\r\n    /**\r\n     * Determine direction based on orientation change.\r\n     * @param {{ beta: number, gamma: number }} orientationChange - the change in device orientation\r\n     * @returns {string | null} determined direction or null\r\n     * @private\r\n     */\r\n    _getDirectionFromOrientation(orientationChange) {\r\n        if (Math.abs(orientationChange.beta) > Math.abs(orientationChange.gamma)) {\r\n            if (orientationChange.beta < -INPUT.MOTION_SENSITIVITY) {\r\n                return DIRECTION_DOWN;\r\n            } else if (orientationChange.beta > INPUT.MOTION_SENSITIVITY) {\r\n                return DIRECTION_UP;\r\n            }\r\n        } else {\r\n            if (orientationChange.gamma < -INPUT.MOTION_SENSITIVITY) {\r\n                return DIRECTION_RIGHT;\r\n            } else if (orientationChange.gamma > INPUT.MOTION_SENSITIVITY) {\r\n                return DIRECTION_LEFT;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Handles visibility change of the document.\r\n     * @private\r\n     */\r\n    _handleVisibilityChange() {\r\n        if (document.hidden && !this._game.state.paused) {\r\n            this._game.togglePause();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Request device orientation permission.\r\n     * @private\r\n     */\r\n    _requestDeviceOrientation() {\r\n        // iOS 13+ requires permission\r\n        DeviceOrientationEvent.requestPermission()\r\n            .then(response => {\r\n                if (response === 'granted') {\r\n                    this._enableMotionControl();\r\n                }\r\n            })\r\n            .catch(console.error);\r\n    }\r\n\r\n    /**\r\n     * Enables motion control for the game.\r\n     * @private\r\n     */\r\n    _enableMotionControl() {\r\n        document.removeEventListener('keydown', this._boundMethods.handleKeyInput);\r\n        window.addEventListener('deviceorientation', this._boundMethods.handleDeviceMovement);\r\n\r\n        this._game.board.removeMotionRequestBtn();\r\n        this._game.state.setSpeed(INPUT.GAME_SPEED_MS__MOTION);\r\n        this._motionAvailable = true;\r\n\r\n        console.log('motion controls activated');\r\n    }\r\n\r\n    /**\r\n     * Disables motion control for the game.\r\n     * @private\r\n     */\r\n    _disableMotionControl() {\r\n        this._game.board.removeMotionRequestBtn();\r\n        window.removeEventListener('deviceorientation', this._handleDeviceMovement);\r\n        this._game.state.setSpeed(INPUT.GAME_SPEED_MS__ARROW);\r\n        this._motionAvailable = false;\r\n    }\r\n\r\n    /**\r\n     * Logs debug information about the current state of motion controls.\r\n     * This method is intended to be called periodically (e.g., in the game loop)\r\n     * to provide ongoing insight into the motion control system's state.\r\n     * @private\r\n     */\r\n    _debugMotionControl() {\r\n        console.log('motion control debug info', {\r\n            motionAvailable: this._motionAvailable,\r\n            deviceOrientation: this._deviceOrientation,\r\n            isChangingDirection: this._game.snake._isChangingDirection,\r\n            snakeDirection: this._game.snake.getCurrentDirection()\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Handles the touch start event.\r\n     * Records the initial Y position of the touch.\r\n     * @param {TouchEvent} ev - touch start event\r\n     * @private\r\n     */\r\n    _handleTouchStart(ev) {\r\n        ev.preventDefault();\r\n\r\n        const firstTouch = ev.changedTouches[0];\r\n        // console.log({\r\n        //     [ev.type]: (firstTouch.screenX, firstTouch.screenY)\r\n        // });\r\n\r\n        this._touchStart = { x: firstTouch.screenX, y: firstTouch.screenY };\r\n    }\r\n\r\n    /**\r\n     * Handles the touch end event.\r\n     * Records the final Y position of the touch and calls handleSwipeGesture.\r\n     * @param {TouchEvent} ev - touch end event\r\n     * @private\r\n     */\r\n    _handleTouchEnd(ev) {\r\n        ev.preventDefault();\r\n\r\n        const firstTouch = ev.changedTouches[0];\r\n        // console.log({\r\n        //     [ev.type]: (firstTouch.screenX, firstTouch.screenY)\r\n        // });\r\n\r\n        this._touchEnd = { x: firstTouch.screenX, y: firstTouch.screenY };\r\n\r\n        this._handleSwipeGesture();\r\n    }\r\n\r\n    /**\r\n     * Handles the gesture based on the swipe direction.\r\n     * Enters fullscreen on upward swipe, exits fullscreen on downward swipe,\r\n     * restarts the game if it has ended, or toggles pause otherwise.\r\n     * @private\r\n     */\r\n    _handleSwipeGesture() {\r\n        if (this._touchStart.y - this._touchEnd.y > INPUT.SWIPE_SENSITIVITY) {\r\n            // console.log(`swiped UP ${downY-upY}px`);\r\n            this._game.board.enterFullScreen();\r\n        } else if (this._touchEnd.y - this._touchStart.y > INPUT.SWIPE_SENSITIVITY) {\r\n            // console.log(`swiped DOWN ${upY-downY}px`);\r\n            this._game.board.exitFullScreen();\r\n        } else if (this._game.state.ended) {\r\n            this._game.restart();\r\n        } else {\r\n            // console.log(`togglePause from handleGesture`);\r\n            this._game.togglePause();\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Represents a command to pause the game.\r\n */\r\nclass PauseCommand {\r\n\r\n    /**\r\n     * Executes the pause command.\r\n     * @param {import('./game').Game} game - game instance\r\n     */\r\n    execute(game) {\r\n        game.togglePause();\r\n    }\r\n}\r\n\r\n/**\r\n * Represents a command to move snek.\r\n */\r\nclass MoveCommand {\r\n\r\n    /**\r\n     * @param {string} direction - direction to move\r\n     */\r\n    constructor(direction) {\r\n        this.direction = direction;\r\n    }\r\n\r\n    /**\r\n     * Executes the move command.\r\n     * @param {import('./game').Game} game - game instance\r\n     */\r\n    execute(game) {\r\n        game.snake.changeDirection(this.direction);\r\n    }\r\n}\r\n","import { GAME_CONFIG } from './config';\r\n\r\nconst { CANVAS } = GAME_CONFIG;\r\n\r\nconst PAUSE_ICON_CHAR_CODE = 0xF4BF;\r\nconst EXCLAMATION_ICON_CHAR_CODE = 0xF33A;\r\n\r\n/**\r\n * A fake \"context manager\" for pixel sharpness.\r\n * https://stackoverflow.com/a/8696641\r\n * @param {CanvasRenderingContext2D} ctx - canvas rendering context\r\n * @param {() => void} cb - callback function to execute within the context\r\n */\r\nfunction withStraddle(ctx, cb) {\r\n    const offset = 0.5;\r\n\r\n    try {\r\n        // turn on 'straddle' trick to avoid blurriness\r\n        ctx.translate(offset, offset);\r\n        cb();\r\n    } finally {\r\n        // turn off 'straddle' trick to avoid blurriness\r\n        ctx.translate(-offset, -offset);\r\n    }\r\n}\r\n\r\n/**\r\n * Draws the game board and background.\r\n * @param {import('./game/game').Game} game - game object\r\n */\r\nexport function drawGame(game) {\r\n    let board = game.board;\r\n    let ctx = board.ctx;\r\n\r\n    ctx.save();\r\n\r\n    withStraddle(ctx, () => {\r\n        ctx.filter = board.activeFilter;\r\n\r\n        // set border and background colors\r\n        ctx.fillStyle = board.color;\r\n        if (board.isGlowing) {\r\n            // note: strokeRect doesn't do a good job of bordering the canvas,\r\n            // so we fall back to CSS styling\r\n\r\n            // https://stackoverflow.com/a/5670984\r\n            board.canvas.style.border = 'none'\r\n            board.canvas.style.outline = `${board.borderColor} dashed thin`;\r\n            board.canvas.style.boxShadow = `0 0 10px ${board.color}`;\r\n            board.canvas.style.transition = 'box-shadow linear 1s';\r\n        } else {\r\n            board.canvas.style.border = `2px solid ${board.borderColor}`;\r\n            board.canvas.style.outline = 'none';\r\n            board.canvas.style.boxShadow = 'none';\r\n            board.canvas.style.transition = 'box-shadow linear 0.5s';\r\n        }\r\n\r\n        ctx.fillRect(0, 0, board.canvas.width, board.canvas.height);\r\n\r\n        if (game.state.paused) {\r\n            let useExclamation = board.needsPermission();\r\n\r\n            const iconSize = CANVAS.GAME_TEXT_FONT_SIZE * board.ratio;\r\n            const iconPadding = 5 * board.ratio;\r\n\r\n            // since filters don't work on iOS safari, we need another visual aid\r\n            // add pause button icon https://icons.getbootstrap.com/icons/pause-btn-fill/\r\n            // or exclamation triangle icon if we still need permissions\r\n            // https://icons.getbootstrap.com/icons/exclamation-triangle-fill/\r\n            ctx.font = `${iconSize}px \"bootstrap-icons\"`;\r\n            ctx.fillStyle = useExclamation ? CANVAS.EXCLAMATION_BTN_COLOR : CANVAS.PAUSE_BTN_COLOR;\r\n            ctx.fillText(String.fromCharCode(\r\n                useExclamation ? EXCLAMATION_ICON_CHAR_CODE : PAUSE_ICON_CHAR_CODE\r\n            ), iconPadding, iconSize + iconPadding, board.canvas.width);\r\n        }\r\n    });\r\n\r\n    ctx.restore();\r\n}\r\n\r\n/**\r\n * Draws snek on the game board.\r\n * @param {import('./snake').Snake} snake - snek object\r\n * @param {import('./board').Board} board - game board\r\n */\r\nexport function drawSnake(snake, board) {\r\n    const ctx = board.ctx;\r\n\r\n    ctx.save();\r\n\r\n    withStraddle(ctx, () => {\r\n        if (snake.isGlowing) {\r\n            // https://stackoverflow.com/a/43676108\r\n            ctx.lineCap = 'round';\r\n            ctx.shadowBlur = 18;\r\n            ctx.shadowColor = snake.color;\r\n        }\r\n\r\n        ctx.fillStyle = snake.color;\r\n        ctx.strokeStyle = snake.borderColor;\r\n\r\n        snake.forEachSegment((/** @type {{ x: number; y: number; }} */ segment) => {\r\n            ctx.fillRect(segment.x, segment.y, board.blockSize, board.blockSize);\r\n            ctx.strokeRect(segment.x, segment.y, board.blockSize, board.blockSize);\r\n        });\r\n    });\r\n\r\n    ctx.restore();\r\n}\r\n\r\n/**\r\n * Draws an item on the game board.\r\n * @param {import('./item').Item} item - item object\r\n * @param {import('./board').Board} board - game board\r\n */\r\nexport function drawItem(item, board) {\r\n    let ctx = board.ctx;\r\n    ctx.save();\r\n\r\n    withStraddle(ctx, () => {\r\n        ctx.fillStyle = item.fillColor;\r\n        ctx.strokeStyle = item.borderColor;\r\n        ctx.fillRect(item.x, item.y, board.blockSize, board.blockSize);\r\n        ctx.strokeRect(item.x, item.y, board.blockSize, board.blockSize);\r\n    });\r\n\r\n    ctx.restore();\r\n}\r\n\r\n/**\r\n * Draws the current score on the game board.\r\n * @param {number} score - current score\r\n * @param {import('./board').Board} board - game board\r\n */\r\nexport function drawScore(score, board) {\r\n    let ctx = board.ctx;\r\n    ctx.save();\r\n\r\n    ctx.font = `${CANVAS.GAME_TEXT_FONT_SIZE * board.ratio}px ${CANVAS.GAME_TEXT_FONT_FAMILY}`;\r\n    ctx.textAlign = 'center';\r\n    ctx.fillStyle = CANVAS.GAME_TEXT_COLOR;\r\n    ctx.fillText(score.toString(), board.canvas.width / 2, (board.canvas.height / 2) - ((CANVAS.GAME_TEXT_FONT_SIZE / 2) * board.ratio), board.canvas.width);\r\n\r\n    ctx.restore();\r\n}\r\n\r\n/**\r\n * Draws the high score on the game board.\r\n * @param {number} score - high score\r\n * @param {import('./board').Board} board - game board\r\n */\r\nexport function drawHighScore(score, board) {\r\n    let ctx = board.ctx;\r\n    ctx.save();\r\n\r\n    ctx.font = `${CANVAS.GAME_TEXT_FONT_SIZE * board.ratio}px ${CANVAS.GAME_TEXT_FONT_FAMILY}`;\r\n    ctx.textAlign = 'center';\r\n    ctx.strokeStyle = CANVAS.HIGH_SCORE_TEXT_COLOR;\r\n    ctx.strokeText(score.toString(), board.canvas.width / 2, (board.canvas.height / 2) + ((CANVAS.GAME_TEXT_FONT_SIZE / 2) * board.ratio), board.canvas.width);\r\n\r\n    ctx.restore();\r\n}\r\n\r\n/**\r\n * Draws the game over message on the game board.\r\n * @param {import('./board').Board} board - game board\r\n */\r\nexport function drawGameOver(board) {\r\n    let ctx = board.ctx;\r\n    ctx.save();\r\n\r\n    ctx.font = `${CANVAS.GAME_TEXT_FONT_SIZE * board.ratio}px ${CANVAS.GAME_TEXT_FONT_FAMILY}`;\r\n    ctx.textAlign = 'center';\r\n    ctx.fillStyle = CANVAS.GAME_TEXT_COLOR;\r\n    ctx.fillText('DED', board.canvas.width / 2, board.canvas.height / 2, board.canvas.width);\r\n\r\n    ctx.restore();\r\n}\r\n","import * as defaultCanvas from '../canvas';\r\n\r\n// fn to create render functions with canvas as injected dependency\r\nexport function createRenderFunctions(canvas = defaultCanvas) {\r\n    /**\r\n     * Renders the current game state.\r\n     * @param {import('./game').Game} game - game object to render\r\n     */\r\n    function renderGame(game) {\r\n        canvas.drawGame(game);\r\n        canvas.drawScore(game.state.score, game.board);\r\n        canvas.drawHighScore(game.state.highScore, game.board);\r\n        canvas.drawItem(game.item, game.board);\r\n        canvas.drawSnake(game.snake, game.board);\r\n    }\r\n\r\n    /**\r\n     * Renders the game over state.\r\n     * @param {import('./game').Game} game - game object to render\r\n     */\r\n    function renderGameOver(game) {\r\n        game.board.setEndGameFilter();\r\n        canvas.drawGame(game);\r\n        canvas.drawItem(game.item, game.board);\r\n        canvas.drawSnake(game.snake, game.board);\r\n        canvas.drawGameOver(game.board);\r\n    }\r\n\r\n    return { renderGame, renderGameOver };\r\n}\r\n\r\n// export the default render functions\r\nconst { renderGame, renderGameOver } = createRenderFunctions();\r\nexport { renderGame, renderGameOver };\r\n","import { GAME_CONFIG } from '../config';\r\n\r\nconst { INPUT, STATE } = GAME_CONFIG;\r\n\r\n/**\r\n * Represents the state of the game.\r\n */\r\nexport class GameState {\r\n\r\n    constructor() {\r\n        // states\r\n        this._paused = false;\r\n        this._ended = false;\r\n\r\n        // values\r\n        this._score = 0;\r\n        this._highScore = this._getItemSafely(STATE.LOCAL_STORAGE_KEY_HIGH_SCORE, 0);\r\n        this._speed = this._getItemSafely(STATE.LOCAL_STORAGE_KEY_GAME_SPEED, INPUT.GAME_SPEED_MS__ARROW);\r\n    }\r\n\r\n    /**\r\n     * Gets the speed of the game, aka time between frame updates, in milliseconds.\r\n     * @returns {number} game speed\r\n     */\r\n    get speed() {\r\n        return this._speed;\r\n    }\r\n\r\n    /**\r\n     * Gets the current score of the game.\r\n     * @returns {number} current score\r\n     */\r\n    get score() {\r\n        return this._score;\r\n    }\r\n\r\n    /**\r\n     * Gets the high score of all games.\r\n     * @returns {number} high score\r\n     */\r\n    get highScore() {\r\n        return this._highScore;\r\n    }\r\n\r\n    /**\r\n     * Gets whether or not the game is paused.\r\n     * @returns {boolean} true if game is paused; false otherwise\r\n     */\r\n    get paused() {\r\n        return this._paused;\r\n    }\r\n\r\n    /**\r\n     * Gets whether or not the game has ended.\r\n     * @returns {boolean} true if game has ended; false otherwise\r\n     */\r\n    get ended() {\r\n        return this._ended;\r\n    }\r\n\r\n    /**\r\n     * Updates the current score.\r\n     * @param {number} increment - amount to increase the score by\r\n     */\r\n    updateScore(increment) {\r\n        this._score += increment;\r\n    }\r\n\r\n    /**\r\n     * Updates the high score if the current score is higher.\r\n     */\r\n    updateHighScore() {\r\n        if (this.score > this.highScore) {\r\n            this._highScore = this.score;\r\n            this._setItemSafely(STATE.LOCAL_STORAGE_KEY_HIGH_SCORE, this.score);\r\n            // TODO: add clearing the high score to control panel\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the game speed.\r\n     * @param {number} speed - new game speed to use\r\n     */\r\n    setSpeed(speed) {\r\n        if (typeof speed !== 'number' || isNaN(speed)) {\r\n            return;\r\n        }\r\n        this._speed = Math.max(0, Math.round(speed));\r\n    }\r\n\r\n    /**\r\n     * Toggles the pause state of the game.\r\n     */\r\n    togglePause() {\r\n        this._paused = !this.paused;\r\n    }\r\n\r\n    /**\r\n     * Ends the game and saves the current game speed.\r\n     */\r\n    endGame() {\r\n        this._ended = true;\r\n        this._setItemSafely(STATE.LOCAL_STORAGE_KEY_GAME_SPEED, this.speed);\r\n    }\r\n\r\n    /**\r\n     * Safely gets an item from localStorage.\r\n     * @param {string} key - The key to retrieve from localStorage\r\n     * @param {*} defaultValue - The default value to return if retrieval fails\r\n     * @returns {*} The value from localStorage or the default value\r\n     * @private\r\n     */\r\n    _getItemSafely(key, defaultValue) {\r\n        try {\r\n            const value = localStorage.getItem(key);\r\n            return value !== null ? JSON.parse(value) : defaultValue;\r\n        } catch (error) {\r\n            console.warn(`Error reading from localStorage: ${error.message}`);\r\n            return defaultValue;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Safely sets an item in localStorage.\r\n     * @param {string} key - The key to set in localStorage\r\n     * @param {*} value - The value to set\r\n     * @private\r\n     */\r\n    _setItemSafely(key, value) {\r\n        try {\r\n            localStorage.setItem(key, JSON.stringify(value));\r\n        } catch (error) {\r\n            console.warn(`Error writing to localStorage: ${error.message}`);\r\n        }\r\n    }\r\n}\r\n","import { Board } from '../board';\r\nimport { GAME_CONFIG } from '../config';\r\nimport { displayErrorMessage } from '../error';\r\nimport { Food, Item, Phase, TELEPORT_CLASSNAME, Teleport, selectRandomItem } from '../item';\r\nimport { Snake } from '../snake';\r\nimport { InputHandler } from './input';\r\nimport { renderGame, renderGameOver } from './render';\r\nimport { GameState } from './state';\r\n\r\nconst { GAME } = GAME_CONFIG;\r\n\r\nconst CANVAS_ID = 'gameCanvas';\r\nconst CONTROL_PANEL_ID = 'controlPanel';\r\n\r\n/**\r\n * Represents the main game logic and state.\r\n */\r\nexport class Game {\r\n\r\n    /**\r\n     * @param {Board} board - game board\r\n     * @param {Snake} snake - snek\r\n     * @param {Item} item - current game item\r\n     */\r\n    constructor(board, snake, item) {\r\n        this.board = board;\r\n        this.snake = snake;\r\n        this.item = item;\r\n\r\n        this.state = new GameState();\r\n        this.input = new InputHandler(this);\r\n\r\n        this._lastUpdateTimestamp = 0;\r\n    }\r\n\r\n    /**\r\n     * Runs the game loop.\r\n     * @param {DOMHighResTimeStamp} now - current timestamp\r\n     */\r\n    run(now) {\r\n        if (this._shouldUpdateFrame(now)) {\r\n            this._updateFrame();\r\n            if (this.state._ended) {\r\n                renderGameOver(this);\r\n                return;\r\n            } else {\r\n                renderGame(this);\r\n            }\r\n        }\r\n\r\n        // run game loop again\r\n        requestAnimationFrame((t) => this.run(t));\r\n    }\r\n\r\n    /**\r\n     * Toggles pause state of the game.\r\n     */\r\n    togglePause() {\r\n        this.state.togglePause();\r\n\r\n        if (this.state.paused) {\r\n            this.snake.pause();\r\n            this.board.setPauseGameFilter();\r\n        } else {\r\n            this.snake.unpause();\r\n            this.board.resetFilter();\r\n        }\r\n\r\n        // TODO: pause/unpause any game sounds\r\n        // this.audio.togglePause();\r\n\r\n        console.log(`game ${this.state.paused ? 'paused' : 'resumed'}`);\r\n    }\r\n\r\n    /**\r\n     * Restarts the game.\r\n     */\r\n    restart() {\r\n        this.input.manageRestartControls(false);\r\n        console.log('game restarted');\r\n        runGame();\r\n    }\r\n\r\n    /**\r\n     * Determines if the current frame of the game loop should be updated.\r\n     * @param {DOMHighResTimeStamp} now - current timestamp\r\n     * @returns {boolean} true if the frame should update; false otherwise\r\n     * @private\r\n     */\r\n    _shouldUpdateFrame(now) {\r\n        if (now - this._lastUpdateTimestamp >= this.state.speed) {\r\n            this._lastUpdateTimestamp = now;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Updates the current frame based on game logic.\r\n     * This method checks the game state and advances snek as necessary.\r\n     * @private\r\n     */\r\n    _updateFrame() {\r\n        if (this.state.ended) return;\r\n        if (!this.state.paused) {\r\n            this._advanceSnake();\r\n            // TODO: add to control panel\r\n            // this.input._debugMotionControl();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Snek movement, collision, and item consumption logic.\r\n     * @private\r\n     */\r\n    _advanceSnake() {\r\n        let didEatBeforeMove = this.snake.didEat(this.item);\r\n\r\n        // move snek, growing if it ate an item\r\n        this.snake.move(didEatBeforeMove);\r\n\r\n        if (didEatBeforeMove) {\r\n            console.log(`snek ate item: ${this.item.type.toUpperCase()}`);\r\n\r\n            this.state.updateScore(GAME.SCORE_INCREMENT);\r\n\r\n            // apply item effects\r\n            this.snake.equip(this.item);\r\n\r\n            // update board effects if necessary\r\n            this.board.setGlow(this.snake.powerUps[TELEPORT_CLASSNAME]);\r\n\r\n            // generate a new item\r\n            this._generateNewItem();\r\n        } else {\r\n            // optionally regenerate item based on game conditions\r\n            this._maybeRegenerateItem();\r\n        }\r\n\r\n        // TODO: add to control panel\r\n        // console.log(`${this.item.type}: ${this.item.x}, ${this.item.y}`);\r\n\r\n        if (this._checkCollision()) {\r\n            this._end();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Generates a new item on the board.\r\n     * @private\r\n     */\r\n    _generateNewItem() {\r\n        let itemClass = selectRandomItem(this.state.score, this.snake.powerUps,\r\n            { alwaysReturnItem: true, reducePowerUpProbability: false }\r\n        );\r\n        if (itemClass !== null) {\r\n            this.item = new itemClass(this.board, this.snake);\r\n            console.log(`new item generated: ${this.item.type.toUpperCase()}`);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Possibly regenerates the current item based on game conditions:\r\n     * (1) when the player is already performing well (high score),\r\n     * we make the food volatile, or able to change or disappear, like power-ups are.\r\n     * (2) when there's already a power-up on the board, we reduce the chance of chain-spawning power-ups.\r\n     * @private\r\n     */\r\n    _maybeRegenerateItem() {\r\n        const foodIsVolatile = this.state.score >= GAME.SCORE_THRESHOLD_FOR_VOLATILE_FOOD;\r\n        if (foodIsVolatile || this.item instanceof Teleport || this.item instanceof Phase) {\r\n            let itemClass = selectRandomItem(this.state.score, this.snake.powerUps,\r\n                {alwaysReturnItem: false, reducePowerUpProbability: true}\r\n            );\r\n            if (itemClass !== null) {\r\n                this.item = new itemClass(this.board, this.snake);\r\n                console.log(`item regenerated: ${this.item.type.toUpperCase()}`);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Checks if snek has collided with the board boundaries or itself.\r\n     * @returns {boolean} true if a collision occurred; false otherwise\r\n     * @private\r\n     */\r\n    _checkCollision() {\r\n        // always set game board glow based on whether or not teleport powerup is equipped\r\n        this.board.setGlow(this.snake.powerUps[TELEPORT_CLASSNAME]);\r\n        return this.snake.didCollide(this.board.width, this.board.height, this.board.blockSize);\r\n    }\r\n\r\n    /**\r\n     * Ends the game and updates final state.\r\n     * @private\r\n     */\r\n    _end() {\r\n        this.state.endGame();\r\n        this.state.updateHighScore();\r\n\r\n        this.input.manageGameControls(false);\r\n        this.input.manageRestartControls(true);\r\n\r\n        console.log(`game over - final score: ${this.state.score}`);\r\n    }\r\n}\r\n\r\n// <!-- GAME EXECUTION HELPERS BELOW -->\r\n\r\n/**\r\n * Initializes and runs the game.\r\n */\r\nexport function runGame() {\r\n    try {\r\n        let board = _initBoard();\r\n        let snake = new Snake(board.height, board.height, board.blockSize);\r\n        let food = new Food(board, snake);\r\n        let game = new Game(board, snake, food);\r\n\r\n        game.input.manageGameControls(true);\r\n\r\n        requestAnimationFrame((t) => game.run(t));\r\n    } catch (error) {\r\n        console.error('failed to initialize game:', error);\r\n        // display an error message to the user\r\n        displayErrorMessage('Failed to start the game. Please refresh the page and try again.', document.getElementById(CANVAS_ID));\r\n    }\r\n}\r\n\r\n/**\r\n * Initializes the game board.\r\n * @returns {Board} initialized game board\r\n * @throws {Error} ff the canvas element is not found or is not an HTMLCanvasElement\r\n * @private\r\n */\r\nfunction _initBoard() {\r\n    let canvas, ctrl_panel;\r\n    if (!(canvas = document.getElementById(CANVAS_ID))) {\r\n        throw new Error(`HTML canvas with id '${CANVAS_ID}' not found`);\r\n    }\r\n    if (!(canvas instanceof HTMLCanvasElement)) {\r\n        throw new Error(`#${CANVAS_ID} element is not an HTML canvas`);\r\n    }\r\n    if (!(ctrl_panel = document.getElementById(CONTROL_PANEL_ID))) {\r\n        console.warn(`control panel element with id '${CONTROL_PANEL_ID}' not found. proceeding without control panel.`);\r\n    }\r\n\r\n    let board = new Board(canvas, ctrl_panel);\r\n\r\n    return board;\r\n}\r\n","import { runGame } from './game/game';\r\n\r\nrunGame();\r\n"],"names":["GAME_CONFIG","BOARD","CTRL_PANEL_HEIGHT","MARGIN_SIZE","NUM_STEPS_ACROSS_CANVAS","DEFAULT_BACKGROUND_COLOR","DEFAULT_BORDER_COLOR","TELEPORT_BORDER_COLOR","TELEPORT_BACKGROUND_COLOR","FILTERS","NONE","PAUSE","ENDGAME","SNAKE","INITIAL_LENGTH","DEFAULT_COLOR","PHASE_BORDER_COLOR","ITEM","FOOD_COLOR","FOOD_BORDER_COLOR","PHASE_COLOR","TELEPORT_COLOR","PHASE_SCORE_THRESHOLD","TELEPORT_SCORE_THRESHOLD","BASE_PHASE_PROBABILITY","BASE_TELEPORT_PROBABILITY","BASE_VOLATILE_FOOD_PROBABILITY","GAME","SCORE_INCREMENT","SCORE_THRESHOLD_FOR_VOLATILE_FOOD","INPUT","GAME_SPEED_MS__ARROW","GAME_SPEED_MS__MOTION","SWIPE_SENSITIVITY","MOTION_SENSITIVITY","MOTION_THROTTLE_TIME_MS","CANVAS","GAME_TEXT_COLOR","HIGH_SCORE_TEXT_COLOR","PAUSE_BTN_COLOR","EXCLAMATION_BTN_COLOR","GAME_TEXT_FONT_FAMILY","GAME_TEXT_FONT_SIZE","STATE","LOCAL_STORAGE_KEY_HIGH_SCORE","LOCAL_STORAGE_KEY_GAME_SPEED","ERROR","MESSAGE_FONT","MESSAGE_COLOR","MESSAGE_BACKGROUND","MOTION_REQUEST_BUTTON_ID","Board","constructor","canvas","ctrlPanel","this","_canvas","_ctrlPanel","ctx","getContext","Error","_boardSize","_calculateBoardSize","_ratio","window","devicePixelRatio","_sizeCanvas","_sizeControlPanel","_width","width","_height","height","_blockSize","_activeFilter","_color","_borderColor","_isGlowing","resetFilter","color","borderColor","isGlowing","activeFilter","blockSize","ratio","setEndGameFilter","setPauseGameFilter","enterFullScreen","requestFullscreen","then","screen","lockOrientationUniversal","lockOrientation","mozLockOrientation","msLockOrientation","e","exitFullScreen","document","exitFullscreen","createMotionRequestBtn","btn","createElement","innerHTML","setAttribute","type","appendChild","getMotionRequestBtn","getElementById","removeMotionRequestBtn","parentNode","removeChild","setGlow","shouldGlow","needsPermission","gridBlockSize","Math","min","innerWidth","innerHeight","floor","style","displayErrorMessage","message","HTMLCanvasElement","console","error","displayErrorInDOM","save","font","fillStyle","messageWidth","measureText","messageHeight","messageX","messageY","fillRect","textAlign","textBaseline","fillText","restore","displayErrorOnCanvas","errorDiv","position","top","left","transform","backgroundColor","padding","borderRadius","zIndex","whiteSpace","maxWidth","overflowWrap","textContent","body","PHASE_CLASSNAME","TELEPORT_CLASSNAME","Item","board","snake","_x","Number","MIN_SAFE_INTEGER","_y","_generate","x","y","fillColor","_randomBlock","forEachSegment","snakeSegment","max","round","random","Food","Teleport","Phase","ITEM_TYPES","none","food","teleport","phase","selectRandomItem","score","powerUps","options","alwaysReturnItem","reducePowerUpProbability","itemChances","teleportProb","calculateTeleportProbability","phaseProb","calculatePhaseProbability","foodProb","noItemProb","probabilities","totalProb","Object","values","reduce","sum","prob","abs","calculateItemProbabilities","selectedItemType","chances","cumulativeProbability","item","probability","entries","pickItem","DIRECTION_LEFT","DIRECTION_RIGHT","DIRECTION_UP","DIRECTION_DOWN","DIRECTIONS","dx","dy","Snake","boardWidth","boardHeight","centerX","centerY","_body","_createBody","_dx","_dxAtPause","_dy","_dyAtPause","_isChangingDirection","_directionMap","Map","length","i","push","getHeadPosition","getCurrentDirection","key","get","move","growing","_advanceHead","_advanceTail","head","unshift","pop","teleportHead","newPosition","callback","forEach","segment","index","pause","unpause","didEat","equip","didCollide","slice","some","log","hitLeftWall","hitRightWall","hitTopWall","hitBottomWall","changeDirection","direction","newDirection","toLowerCase","getDirection","currentDirection","_getCurrentDirection","dir2","dir1","_setNewDirection","magnitude","normalizeDirection","SPACE_KEY","LEFT_KEY","RIGHT_KEY","UP_KEY","DOWN_KEY","InputHandler","game","_game","_motionAvailable","_deviceOrientation","beta","gamma","_lastOrientationUpdate","_touchStart","_touchEnd","_boundMethods","_bindMethods","manageGameControls","shouldAdd","_manageKeyboardControls","_manageTouchControls","_manageVisibilityControl","_managePauseControl","_manageFullscreenControl","_manageDeviceOrientationControl","manageRestartControls","action","removeEventListener","handleKeyInput","handleRestart","_handleKeyInput","bind","handleDeviceMovement","_handleDeviceMovement","handleVisibilityChange","_handleVisibilityChange","requestDeviceOrientation","_requestDeviceOrientation","togglePause","handleTouchStart","_handleTouchStart","handleTouchEnd","_handleTouchEnd","_handleRestart","DeviceOrientationEvent","requestPermission","addEventListener","event","command","MoveCommand","PauseCommand","code","state","_ended","_disableMotionControl","execute","ev","KeyboardEvent","restart","now","Date","currentOrientation","orientationChange","_isSignificantMotion","_enableMotionControl","_getDirectionFromOrientation","hidden","paused","response","catch","setSpeed","_debugMotionControl","motionAvailable","deviceOrientation","isChangingDirection","snakeDirection","preventDefault","firstTouch","changedTouches","screenX","screenY","_handleSwipeGesture","ended","withStraddle","cb","offset","translate","filter","border","outline","boxShadow","transition","useExclamation","iconSize","iconPadding","String","fromCharCode","lineCap","shadowBlur","shadowColor","strokeStyle","strokeRect","toString","strokeText","renderGame","renderGameOver","defaultCanvas","drawGame","drawScore","drawHighScore","highScore","drawItem","drawSnake","drawGameOver","createRenderFunctions","GameState","_paused","_score","_highScore","_getItemSafely","_speed","speed","updateScore","increment","updateHighScore","_setItemSafely","isNaN","endGame","defaultValue","value","localStorage","getItem","JSON","parse","warn","setItem","stringify","CANVAS_ID","CONTROL_PANEL_ID","Game","input","_lastUpdateTimestamp","run","_shouldUpdateFrame","_updateFrame","requestAnimationFrame","t","runGame","_advanceSnake","didEatBeforeMove","toUpperCase","_generateNewItem","_maybeRegenerateItem","_checkCollision","_end","itemClass","ctrl_panel","_initBoard"],"mappings":"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"}