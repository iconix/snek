{"version":3,"file":"debug__orientation.min.js","sources":["../src/js/config.js","../src/js/direction.js","../src/js/motion.js","../src/js/debug__orientation.js"],"sourcesContent":["export const GAME_CONFIG = {\n    BOARD: {\n        CTRL_PANEL_HEIGHT: 50,  // pixels\n        MARGIN_SIZE: 20,  // pixels\n        NUM_STEPS_ACROSS_CANVAS: 30,\n        DEFAULT_BACKGROUND_COLOR: 'white',\n        DEFAULT_BORDER_COLOR: 'darkgreen',\n        TELEPORT_BORDER_COLOR: 'blue',\n        TELEPORT_BACKGROUND_COLOR: '#e2f1fa',  // a light blue\n        FILTERS: {\n            NONE: 'none',\n            PAUSE: 'contrast(1.4) sepia(1)',\n            ENDGAME: 'grayscale(0.8) blur(0.5px)',\n        },\n    },\n\n    SNAKE: {\n        INITIAL_LENGTH: 5,\n        DEFAULT_COLOR: 'lightgreen',\n        DEFAULT_BORDER_COLOR: 'darkgreen',\n        PHASE_BORDER_COLOR: 'violet',\n    },\n\n    ITEM: {\n        FOOD_COLOR: 'red',\n        FOOD_BORDER_COLOR: 'darkred',\n        PHASE_COLOR: 'orchid',\n        PHASE_BORDER_COLOR: 'violet',\n        TELEPORT_COLOR: 'blue',\n        TELEPORT_BORDER_COLOR: 'darkblue',\n        PHASE_SCORE_THRESHOLD: 150,\n        TELEPORT_SCORE_THRESHOLD: 50,\n        BASE_PHASE_PROBABILITY: 0.1,\n        BASE_TELEPORT_PROBABILITY: 0.1,\n        BASE_VOLATILE_FOOD_PROBABILITY: 0.01,\n    },\n\n    GAME: {\n        SCORE_INCREMENT: 10,\n        SCORE_THRESHOLD_FOR_VOLATILE_FOOD: 100,\n        SPEED_MS__ARROW: 100,\n        SPEED_MS__MOTION: 125,          // slow down game since harder with motion controls\n    },\n\n    INPUT: {\n        SWIPE_SENSITIVITY: 10,          // delta of pixels needed to consider touch mvmt a 'swipe'\n        MOTION_SENSITIVITY: 15,         // degree of motion needed to consider a device mvmt as intentional\n        MOTION_THROTTLE_TIME_MS: 100,   // min time between motion control updates to prevent over-sensitivity\n        // MOTION_DEADZONE: 2,             // in degrees TODO:\n        // DOMINANT_DIRECTION_THRESHOLD: 5,// TODO:\n    },\n\n    CANVAS: {\n        GAME_TEXT_COLOR: 'gray',\n        HIGH_SCORE_TEXT_COLOR: 'goldenrod',\n        PAUSE_BTN_COLOR: 'darkkhaki',\n        EXCLAMATION_BTN_COLOR: 'darkkhaki',\n        GAME_TEXT_FONT_FAMILY: '\"Saira\", serif',\n        GAME_TEXT_FONT_SIZE: 50,\n    },\n\n    STATE: {\n        LOCAL_STORAGE_KEY_HIGH_SCORE: 'highScore',\n        LOCAL_STORAGE_KEY_GAME_SPEED: 'gameSpeed',\n    },\n\n    ERROR: {\n        // ERROR_MESSAGE_DURATION: 5000,\n        MESSAGE_FONT: '20px Arial',\n        MESSAGE_COLOR: 'red',\n        MESSAGE_BACKGROUND: 'rgba(0, 0, 0, 0.7)',\n    },\n};\n","export const DIRECTION_LEFT = 'left';\nexport const DIRECTION_RIGHT = 'right';\nexport const DIRECTION_UP = 'up';\nexport const DIRECTION_DOWN = 'down';\n\n/**\n * @typedef {Object} Direction\n * @property {number} dx - change in x direction\n * @property {number} dy - change in y direction\n */\n\n/**\n * Object mapping direction strings to their corresponding Direction objects.\n * @type {Object.<string, Direction>}\n */\nexport const DIRECTIONS = {\n    [DIRECTION_LEFT]:  { dx: -1, dy: 0 },\n    [DIRECTION_RIGHT]: { dx: 1,  dy: 0 },\n    [DIRECTION_UP]:    { dx: 0,  dy: -1 },\n    [DIRECTION_DOWN]:  { dx: 0,  dy: 1 },\n};\n\n/**\n * Gets the Direction object for a given direction string.\n * @param {string} direction - direction string\n * @returns {Direction | null} Direction object or null if not found\n */\nexport function getDirection(direction) {\n    return DIRECTIONS[direction.toLowerCase()] || null;\n}\n\n/**\n * Checks if two directions are opposite to each other.\n * @param {Direction} dir1 - first direction\n * @param {Direction} dir2 - second direction\n * @returns {boolean} true if the directions are opposite; false otherwise\n */\nexport function isOppositeDirection(dir1, dir2) {\n    return dir1.dx === -dir2.dx && dir1.dy === -dir2.dy;\n}\n\n/**\n * Normalizes a direction vector to have a magnitude of 1.\n * @param {number} dx - x component of the direction\n * @param {number} dy - y component of the direction\n * @returns {Direction} normalized direction\n */\nexport function normalizeDirection(dx, dy) {\n    const magnitude = Math.max(Math.abs(dx), Math.abs(dy));\n    if (magnitude === 0) {\n        return { dx: 0, dy: 0 };\n    }\n    return { dx: dx / magnitude, dy: dy / magnitude };\n}\n","import { GAME_CONFIG } from './config';\nimport { DIRECTION_DOWN, DIRECTION_LEFT, DIRECTION_RIGHT, DIRECTION_UP } from './direction';\n\nconst { INPUT } = GAME_CONFIG;\n\n/**\n * Represents a visual indicator for motion controls.\n */\nexport class MotionControlIndicator {\n\n    /**\n     * @param {HTMLDivElement} container - container element to render the indicator in\n     * @param {Object} [options={}] - configuration options for the indicator\n     * @param {boolean} [options.showInfo=true] - whether to show additional information\n     * @param {string} [options.position='inline'] - position of the indicator ('inline' or 'corner')\n     */\n    constructor(container, options = {}) {\n        this.container = container;\n        this.options = {\n            showInfo: true,\n            position: 'inline',\n            ...options\n        };\n        this._create();\n        this._initialOrientation = null;\n    }\n\n    /**\n     * Updates the motion control indicator based on the current orientation and direction.\n     * @param {{ beta: number, gamma: number }} orientation - current device orientation\n     * @param {string|null} direction - current direction of movement (UP, DOWN, LEFT, RIGHT, or null)\n     * TODO: sensitivity\n     */\n    // update(orientation, direction, sensitivity) {\n    update(orientation, direction) {\n        // initialize reference point if not set\n        if (!this._initialOrientation) {\n            this._initialOrientation = {\n                beta: orientation.beta,\n                gamma: orientation.gamma\n            };\n            return; // skip first update to maintain center position\n        }\n\n        const { beta, gamma } = orientation;\n        const maxTilt = 30;\n\n        // calculate relative tilt from initial position\n        const relativeBeta = beta - this._initialOrientation.beta;\n        const relativeGamma = gamma - this._initialOrientation.gamma;\n\n        // clamp the relative values to our maximum tilt range\n        const tiltX = Math.min(Math.max(relativeGamma, -maxTilt), maxTilt) / maxTilt;\n        const tiltY = Math.min(Math.max(relativeBeta, -maxTilt), maxTilt) / maxTilt;\n\n        const dotPx = this.options.position === 'corner' ? 40 : 60;\n        if (this.dot instanceof HTMLDivElement) {\n            this.dot.style.transform = `translate(${tiltX * dotPx}px, ${tiltY * dotPx}px)`;\n        }\n\n        if (this.arrows) {\n            this.arrows.forEach(arrow => arrow.classList.remove('active'));\n        }\n        if (direction) {\n            const activeArrow = this.container.querySelector(`.arrow.${direction.toLowerCase()}`);\n            if (activeArrow instanceof HTMLDivElement) {\n                activeArrow.classList.add('active')\n            }\n\n            if (this.options.showInfo && this.directionValue instanceof HTMLSpanElement) {\n                if (this.directionValue.textContent !== direction) {\n                    this.directionValue.classList.add('highlight');\n                    this.directionValue.textContent = direction;\n                    setTimeout(() => {\n                        if (this.directionValue instanceof HTMLSpanElement) {\n                            this.directionValue.classList.remove('highlight');\n                        }\n                    }, 300);\n                }\n            }\n        }\n\n        if (this.options.showInfo) {\n            if (this.betaValue instanceof HTMLSpanElement) {\n                this.betaValue.textContent = beta.toFixed(2);\n            }\n            if (this.gammaValue instanceof HTMLSpanElement) {\n                this.gammaValue.textContent = gamma.toFixed(2);\n            }\n            // if (this.sensitivityValue instanceof HTMLSpanElement) {\n            //     this.sensitivityValue.textContent = sensitivity.toFixed(2);\n            // }\n        }\n    }\n\n    /**\n     * Makes the motion control indicator visible, if it exists.\n     */\n    show() {\n        if (this.container) {\n            this.container.style.display = 'block';\n        }\n    }\n\n    /**\n     * Hides the motion control indicator, if it exists.\n     */\n    hide() {\n        if (this.container) {\n            this.container.style.display = 'none';\n        }\n    }\n\n    /**\n     * Creates the DOM elements for the motion control indicator.\n     * @private\n     */\n    _create() {\n        this.container.innerHTML = `\n            <div class=\"motion-indicator ${this.options.position}\">\n                <div class=\"tilt-indicator ${this.options.position}\">\n                    <div class=\"dot\"></div>\n                    <div class=\"arrow up ${this.options.position}\">\\u25B2\\uFE0E</div>\n                    <div class=\"arrow down ${this.options.position}\">\\u25BC\\uFE0E</div>\n                    <div class=\"arrow left ${this.options.position}\">\\u25C0\\uFE0E</div>\n                    <div class=\"arrow right ${this.options.position}\">\\u25B6\\uFE0E</div>\n                </div>\n                ${this.options.showInfo ? `\n                <div class=\"info\">\n                    <p>Direction: <span class=\"direction-value\">None</span></p>\n                    <!-- <p>Sensitivity: <span class=\"sensitivity-value\">1.00</span></p> -->\n                    <p>Beta: <span class=\"beta-value\">0.00</span>°</p>\n                    <p>Gamma: <span class=\"gamma-value\">0.00</span>°</p>\n                </div>\n                ` : ''}\n            </div>\n        `;\n\n        this.dot = this.container.querySelector('.dot');\n        this.arrows = this.container.querySelectorAll('.arrow');\n        this.directionValue = this.container.querySelector('.direction-value');\n        // this.sensitivityValue = this.container.querySelector('.sensitivity-value');\n        this.betaValue = this.container.querySelector('.beta-value');\n        this.gammaValue = this.container.querySelector('.gamma-value');\n\n        this._addStyles();\n    }\n\n    /**\n     * Adds the necessary styles for the motion control indicator.\n     * @private\n     */\n    _addStyles() {\n        const style = document.createElement('style');\n        style.textContent = `\n            .motion-indicator {\n                display: flex;\n                justify-content: space-between;\n                align-items: center;\n            }\n            .motion-indicator.corner {\n                position: fixed;\n                bottom: 20px;\n                right: 20px;\n                background: white;\n                padding: 10px;\n                border-radius: 10px;\n                box-shadow: 0 0 10px rgba(0,0,0,0.1);\n            }\n            .tilt-indicator {\n                width: 150px;\n                height: 150px;\n                border: 2px solid #ccc;\n                border-radius: 10px;\n                position: relative;\n                overflow: hidden;\n            }\n            .tilt-indicator.corner {\n                width: 100px;\n                height: 100px;\n            }\n            .dot {\n                width: 20px;\n                height: 20px;\n                background: blue;\n                border-radius: 50%;\n                position: absolute;\n                top: 50%;\n                left: 50%;\n                transform: translate(-50%, -50%);\n                transition: transform 0.1s ease;\n            }\n            .arrow {\n                position: absolute;\n                color: #ccc;\n                font-size: 24px;\n                transition: color 0.3s ease;\n            }\n            .arrow.up { top: 10px; left: 50%; transform: translateX(-50%); }\n            .arrow.down { bottom: 10px; left: 50%; transform: translateX(-50%); }\n            .arrow.left { left: 10px; top: 50%; transform: translateY(-50%); }\n            .arrow.right { right: 10px; top: 50%; transform: translateY(-50%); }\n            .arrow.active { color: green; }\n            .arrow.up.corner { top: 5px; }\n            .arrow.down.corner { bottom: 5px; }\n            .arrow.left.corner { left: 5px; }\n            .arrow.right.corner { right: 5px; }\n            .info {\n                text-align: left;\n                margin-left: 20px;\n            }\n            .info p {\n                margin: 5px 0;\n            }\n            .direction-value {\n                display: inline-block;\n                padding: 2px 8px;\n                border-radius: 4px;\n                transition: background-color 0.3s ease;\n            }\n            .direction-value.highlight {\n                background-color: #ffd700;\n            }\n        `;\n        document.head.appendChild(style);\n    }\n}\n\n/**\n * Calculates the motion control based on the current and last device orientation,\n * as well as the time between updates to prevent overly frequent updates.\n *\n * @param {{ beta: number, gamma: number }} currentOrientation - current device orientation\n * TODO: initialOrientation\n * @param {{ beta: number, gamma: number }} lastOrientation - last device orientation\n * @param {number} currentUpdateTime - timestamp of the current update\n * @param {number} lastUpdateTime - timestamp of the last update\n * TODO: sensitivityMultiplier\n *\n * @returns {string|null} direction - calculated direction (UP, DOWN, LEFT, RIGHT),\n *                        or null if no significant motion or if the update is too soon\n */\n// export function calculateMotionControl(currentOrientation, initialOrientation, lastOrientation, currentUpdateTime, lastUpdateTime, sensitivityMultiplier) {\n    export function calculateMotionControl(currentOrientation, initialOrientation, lastOrientation, currentUpdateTime, lastUpdateTime) {\n    if (!initialOrientation) {\n        // return { direction: null, sensitivity: sensitivityMultiplier };\n        // return null on first update to prevent immediate movement\n        return null;\n    }\n\n    // ensure we are not updating too frequently\n    if (currentUpdateTime - lastUpdateTime < INPUT.MOTION_THROTTLE_TIME_MS) {\n        // return { direction: null, sensitivity: sensitivityMultiplier };\n        return null;\n    }\n\n    // calculate change relative to initial orientation\n    // const totalChange = {\n    //     beta: currentOrientation.beta - initialOrientation.beta,\n    //     gamma: currentOrientation.gamma - initialOrientation.gamma\n    // };\n\n    // calculate change since last update\n    const recentChange = {\n        beta: currentOrientation.beta - lastOrientation.beta,\n        gamma: currentOrientation.gamma - lastOrientation.gamma\n    };\n\n    // update sensitivity based on total change from initial position\n    // const magnitudeChange = Math.sqrt(totalChange.beta ** 2 + totalChange.gamma ** 2);\n    // const newSensitivityMultiplier = 1 + (magnitudeChange / 45);\n\n    // // apply deadzone to recent change\n    // const adjustedDeadzone = INPUT.MOTION_DEADZONE / newSensitivityMultiplier;\n    // if (Math.abs(recentChange.beta) <= adjustedDeadzone) recentChange.beta = 0;\n    // if (Math.abs(recentChange.gamma) <= adjustedDeadzone) recentChange.gamma = 0;\n\n    // determine dominant direction based on recent change\n    // const direction = isSignificantMotion(recentChange, sensitivityMultiplier) ? getDirectionFromOrientation(recentChange) : null;\n    // return {\n    //     direction,\n    //     sensitivity: newSensitivityMultiplier\n    // };\n    return isSignificantMotion(recentChange) ? getDirectionFromOrientation(recentChange) : null;\n}\n\n/**\n * Determines if a change in device orientation is significant enough to trigger a direction change.\n * Filters out small, unintentional device movements so we respond only to deliberate motions.\n * @param {Object} orientationChange - change in device orientation\n * @param {number} orientationChange.beta - change in beta (x-axis rotation) in degrees\n * @param {number} orientationChange.gamma - change in gamma (y-axis rotation) in degrees\n    * @returns {boolean} true if the motion is considered significant; false otherwise\n * TODO: sensitivityMultiplier\n * @private\n */\n// function isSignificantMotion(orientationChange, sensitivityMultiplier) {\nfunction isSignificantMotion(orientationChange) {\n    const threshold = INPUT.MOTION_SENSITIVITY;\n    return Math.abs(orientationChange.beta) > threshold || Math.abs(orientationChange.gamma) > threshold;\n}\n\n/**\n* Determine direction based on orientation change.\n* @param {{ beta: number, gamma: number }} orientationChange - the change in device orientation\n* @returns {string | null} determined direction or null\n* @private\n*/\nfunction getDirectionFromOrientation(orientationChange) {\n    let direction = null;\n\n    // // determine dominant direction based on recent change\n    // const absBeta = Math.abs(orientationChange.beta);\n    // const absGamma = Math.abs(orientationChange.gamma);\n\n    // if (absBeta > absGamma && absBeta - absGamma > INPUT.DOMINANT_DIRECTION_THRESHOLD) {\n    if (Math.abs(orientationChange.beta) > Math.abs(orientationChange.gamma)) {\n        direction = orientationChange.beta < 0 ? DIRECTION_UP : DIRECTION_DOWN;\n        // } else if (absGamma > absBeta && absGamma - absBeta > INPUT.DOMINANT_DIRECTION_THRESHOLD) {\n    } else {\n        direction = orientationChange.gamma < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;\n    }\n    return direction;\n}\n","import { MotionControlIndicator, calculateMotionControl } from './motion';\n\nfunction initDebugPage() {\n    const container = document.getElementById('motionIndicator');\n    if (!(container instanceof HTMLDivElement)) {\n        console.error('motion indicator container not found');\n        return;\n    }\n\n    const indicator = new MotionControlIndicator(container, {\n        showInfo: true,\n        position: 'inline'\n    });\n\n    let initialOrientation = null;\n    let lastOrientation = null;\n    let lastOrientationUpdateTime = null;\n    let snakeDirection = null;\n    // let sensitivityMultiplier = 1;\n\n    if (window.DeviceOrientationEvent) {\n        if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {\n            const button = document.getElementById('requestPermission');\n            if (button instanceof HTMLButtonElement) {\n                button.style.display = 'block';\n                button.addEventListener('click', requestOrientationPermission);\n            }\n        } else {\n            window.addEventListener('deviceorientation', handleOrientation);\n        }\n    } else {\n        showError(\"sorry, your browser doesn't support Device Orientation\");\n    }\n\n    function requestOrientationPermission() {\n        DeviceOrientationEvent.requestPermission()\n            .then(permissionState => {\n                if (permissionState === 'granted') {\n                    window.addEventListener('deviceorientation', handleOrientation);\n                    hideError();\n\n                    const button = document.getElementById('requestPermission');\n                    if (button instanceof HTMLButtonElement) {\n                        button.style.display = 'none';\n                    }\n                } else {\n                    showError('permission to access device orientation was denied.');\n                }\n            })\n            .catch(console.error);\n    }\n\n    function handleOrientation(event) {\n        const currentUpdateTime = Date.now();\n        const currentOrientation = {\n            beta: event.beta || 0,\n            gamma: event.gamma || 0\n        };\n\n        if (!initialOrientation) {\n            initialOrientation = { ...currentOrientation };\n            lastOrientation = { ...currentOrientation };\n        }\n\n        // const { direction, sensitivity } = calculateMotionControl(\n        const direction = calculateMotionControl(\n            currentOrientation,\n            initialOrientation,\n            lastOrientation,\n            currentUpdateTime,\n            lastOrientationUpdateTime\n        );\n\n        // sensitivityMultiplier = sensitivity;\n\n        if (direction) {\n            snakeDirection = direction;\n            console.log('direction changed:', snakeDirection);\n\n            lastOrientationUpdateTime = currentUpdateTime;\n            lastOrientation = currentOrientation;\n        }\n\n        // indicator.update(currentOrientation, snakeDirection, sensitivityMultiplier);\n        indicator.update(currentOrientation, snakeDirection);\n    }\n\n    function showError(message) {\n        const errorElement = document.getElementById('errorMessage');\n        if (errorElement) {\n            errorElement.textContent = message;\n        }\n    }\n\n    function hideError() {\n        const errorElement = document.getElementById('errorMessage');\n        if (errorElement) {\n            errorElement.textContent = '';\n        }\n    }\n}\n\ndocument.addEventListener('DOMContentLoaded', initDebugPage);\n"],"names":["DIRECTION_LEFT","DIRECTION_RIGHT","DIRECTION_DOWN","INPUT","BOARD","CTRL_PANEL_HEIGHT","MARGIN_SIZE","NUM_STEPS_ACROSS_CANVAS","DEFAULT_BACKGROUND_COLOR","DEFAULT_BORDER_COLOR","TELEPORT_BORDER_COLOR","TELEPORT_BACKGROUND_COLOR","FILTERS","NONE","PAUSE","ENDGAME","SNAKE","INITIAL_LENGTH","DEFAULT_COLOR","PHASE_BORDER_COLOR","ITEM","FOOD_COLOR","FOOD_BORDER_COLOR","PHASE_COLOR","TELEPORT_COLOR","PHASE_SCORE_THRESHOLD","TELEPORT_SCORE_THRESHOLD","BASE_PHASE_PROBABILITY","BASE_TELEPORT_PROBABILITY","BASE_VOLATILE_FOOD_PROBABILITY","GAME","SCORE_INCREMENT","SCORE_THRESHOLD_FOR_VOLATILE_FOOD","SPEED_MS__ARROW","SPEED_MS__MOTION","SWIPE_SENSITIVITY","MOTION_SENSITIVITY","MOTION_THROTTLE_TIME_MS","CANVAS","GAME_TEXT_COLOR","HIGH_SCORE_TEXT_COLOR","PAUSE_BTN_COLOR","EXCLAMATION_BTN_COLOR","GAME_TEXT_FONT_FAMILY","GAME_TEXT_FONT_SIZE","STATE","LOCAL_STORAGE_KEY_HIGH_SCORE","LOCAL_STORAGE_KEY_GAME_SPEED","ERROR","MESSAGE_FONT","MESSAGE_COLOR","MESSAGE_BACKGROUND","MotionControlIndicator","constructor","container","options","this","showInfo","position","_create","_initialOrientation","update","orientation","direction","beta","gamma","maxTilt","relativeBeta","relativeGamma","tiltX","Math","min","max","tiltY","dotPx","dot","HTMLDivElement","style","transform","arrows","forEach","arrow","classList","remove","activeArrow","querySelector","toLowerCase","add","directionValue","HTMLSpanElement","textContent","setTimeout","betaValue","toFixed","gammaValue","show","display","hide","innerHTML","querySelectorAll","_addStyles","document","createElement","head","appendChild","calculateMotionControl","currentOrientation","initialOrientation","lastOrientation","currentUpdateTime","lastUpdateTime","recentChange","orientationChange","threshold","abs","isSignificantMotion","getDirectionFromOrientation","addEventListener","getElementById","console","error","indicator","lastOrientationUpdateTime","snakeDirection","window","DeviceOrientationEvent","requestPermission","button","HTMLButtonElement","then","permissionState","handleOrientation","errorElement","hideError","showError","catch","event","Date","now","log","message"],"mappings":"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"}