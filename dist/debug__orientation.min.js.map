{"version":3,"file":"debug__orientation.min.js","sources":["../src/js/config.js","../src/js/direction.js","../src/js/motion.js","../src/js/debug__orientation.js"],"sourcesContent":["export const GAME_CONFIG = {\n    BOARD: {\n        CTRL_PANEL_HEIGHT: 50,  // pixels\n        MARGIN_SIZE: 20,  // pixels\n        NUM_STEPS_ACROSS_CANVAS: 30,\n        DEFAULT_BACKGROUND_COLOR: 'white',\n        DEFAULT_BORDER_COLOR: 'darkgreen',\n        TELEPORT_BORDER_COLOR: 'blue',\n        TELEPORT_BACKGROUND_COLOR: '#e2f1fa',  // a light blue\n        FILTERS: {\n            NONE: 'none',\n            PAUSE: 'contrast(1.4) sepia(1)',\n            ENDGAME: 'grayscale(0.8) blur(0.5px)',\n        },\n    },\n\n    SNAKE: {\n        INITIAL_LENGTH: 5,\n        DEFAULT_COLOR: 'lightgreen',\n        DEFAULT_BORDER_COLOR: 'darkgreen',\n        PHASE_BORDER_COLOR: 'violet',\n    },\n\n    ITEM: {\n        FOOD_COLOR: 'red',\n        FOOD_BORDER_COLOR: 'darkred',\n        PHASE_COLOR: 'orchid',\n        PHASE_BORDER_COLOR: 'violet',\n        TELEPORT_COLOR: 'blue',\n        TELEPORT_BORDER_COLOR: 'darkblue',\n        PHASE_SCORE_THRESHOLD: 150,\n        TELEPORT_SCORE_THRESHOLD: 50,\n        BASE_PHASE_PROBABILITY: 0.1,\n        BASE_TELEPORT_PROBABILITY: 0.1,\n        BASE_VOLATILE_FOOD_PROBABILITY: 0.01,\n    },\n\n    GAME: {\n        SCORE_INCREMENT: 10,\n        SCORE_THRESHOLD_FOR_VOLATILE_FOOD: 100,\n        SPEED_MS__ARROW: 100,\n        SPEED_MS__MOTION: 125,          // slow down game since harder with motion controls\n    },\n\n    INPUT: {\n        SWIPE_SENSITIVITY: 10,          // delta of pixels needed to consider touch mvmt a 'swipe'\n        MOTION_SENSITIVITY: 15,         // degree of motion needed to consider a device mvmt as intentional\n        MOTION_THROTTLE_TIME_MS: 100,   // min time between motion control updates to prevent over-sensitivity\n    },\n\n    CANVAS: {\n        GAME_TEXT_COLOR: 'gray',\n        HIGH_SCORE_TEXT_COLOR: 'goldenrod',\n        PAUSE_BTN_COLOR: 'darkkhaki',\n        EXCLAMATION_BTN_COLOR: 'darkkhaki',\n        GAME_TEXT_FONT_FAMILY: '\"Saira\", serif',\n        GAME_TEXT_FONT_SIZE: 50,\n    },\n\n    STATE: {\n        LOCAL_STORAGE_KEY_HIGH_SCORE: 'highScore',\n        LOCAL_STORAGE_KEY_GAME_SPEED: 'gameSpeed',\n    },\n\n    ERROR: {\n        // ERROR_MESSAGE_DURATION: 5000,\n        MESSAGE_FONT: '20px Arial',\n        MESSAGE_COLOR: 'red',\n        MESSAGE_BACKGROUND: 'rgba(0, 0, 0, 0.7)',\n    },\n};\n","export const DIRECTION_LEFT = 'left';\nexport const DIRECTION_RIGHT = 'right';\nexport const DIRECTION_UP = 'up';\nexport const DIRECTION_DOWN = 'down';\n\n/**\n * @typedef {Object} Direction\n * @property {number} dx - change in x direction\n * @property {number} dy - change in y direction\n */\n\n/**\n * Object mapping direction strings to their corresponding Direction objects.\n * @type {Object.<string, Direction>}\n */\nexport const DIRECTIONS = {\n    [DIRECTION_LEFT]:  { dx: -1, dy: 0 },\n    [DIRECTION_RIGHT]: { dx: 1,  dy: 0 },\n    [DIRECTION_UP]:    { dx: 0,  dy: -1 },\n    [DIRECTION_DOWN]:  { dx: 0,  dy: 1 },\n};\n\n/**\n * Gets the Direction object for a given direction string.\n * @param {string} direction - direction string\n * @returns {Direction | null} Direction object or null if not found\n */\nexport function getDirection(direction) {\n    return DIRECTIONS[direction.toLowerCase()] || null;\n}\n\n/**\n * Checks if two directions are opposite to each other.\n * @param {Direction} dir1 - first direction\n * @param {Direction} dir2 - second direction\n * @returns {boolean} true if the directions are opposite; false otherwise\n */\nexport function isOppositeDirection(dir1, dir2) {\n    return dir1.dx === -dir2.dx && dir1.dy === -dir2.dy;\n}\n\n/**\n * Normalizes a direction vector to have a magnitude of 1.\n * @param {number} dx - x component of the direction\n * @param {number} dy - y component of the direction\n * @returns {Direction} normalized direction\n */\nexport function normalizeDirection(dx, dy) {\n    const magnitude = Math.max(Math.abs(dx), Math.abs(dy));\n    if (magnitude === 0) {\n        return { dx: 0, dy: 0 };\n    }\n    return { dx: dx / magnitude, dy: dy / magnitude };\n}\n","import { GAME_CONFIG } from './config';\nimport { DIRECTION_DOWN, DIRECTION_LEFT, DIRECTION_RIGHT, DIRECTION_UP } from './direction';\n\nconst { INPUT } = GAME_CONFIG;\n\n/**\n * Represents a visual indicator for motion controls.\n */\nexport class MotionControlIndicator {\n\n    /**\n     * @param {HTMLDivElement} container - container element to render the indicator in\n     * @param {Object} [options={}] - configuration options for the indicator\n     * @param {boolean} [options.showInfo=true] - whether to show additional information\n     * @param {string} [options.position='inline'] - position of the indicator ('inline' or 'corner')\n     */\n    constructor(container, options = {}) {\n        this.container = container;\n        this.options = {\n            showInfo: true,\n            position: 'inline',\n            ...options\n        };\n        this._create();\n    }\n\n    /**\n     * Updates the motion control indicator based on the current orientation and direction.\n     * @param {{ beta: number, gamma: number }} orientation - current device orientation\n     * @param {string|null} direction - current direction of movement (UP, DOWN, LEFT, RIGHT, or null)\n     */\n    update(orientation, direction) {\n        const { beta, gamma } = orientation;\n        const maxTilt = 30;\n        const tiltX = Math.min(Math.max(gamma, -maxTilt), maxTilt) / maxTilt;\n        const tiltY = Math.min(Math.max(beta, -maxTilt), maxTilt) / maxTilt;\n\n        const dotPx = this.options.position === 'corner' ? 40 : 60;\n        if (this.dot instanceof HTMLDivElement) {\n            this.dot.style.transform = `translate(${tiltX * dotPx}px, ${tiltY * dotPx}px)`;\n        }\n\n        if (this.arrows) {\n            this.arrows.forEach(arrow => arrow.classList.remove('active'));\n        }\n        if (direction) {\n            const activeArrow = this.container.querySelector(`.arrow.${direction.toLowerCase()}`);\n            if (activeArrow instanceof HTMLDivElement) {\n                activeArrow.classList.add('active')\n            }\n\n            if (this.options.showInfo && this.directionValue instanceof HTMLSpanElement) {\n                if (this.directionValue.textContent !== direction) {\n                    this.directionValue.classList.add('highlight');\n                    this.directionValue.textContent = direction;\n                    setTimeout(() => {\n                        if (this.directionValue instanceof HTMLSpanElement) {\n                            this.directionValue.classList.remove('highlight');\n                        }\n                    }, 300);\n                }\n            }\n        }\n\n        if (this.options.showInfo) {\n            if (this.betaValue instanceof HTMLSpanElement) {\n                this.betaValue.textContent = beta.toFixed(2);\n            }\n            if (this.gammaValue instanceof HTMLSpanElement) {\n                this.gammaValue.textContent = gamma.toFixed(2);\n            }\n        }\n    }\n\n    /**\n     * Makes the motion control indicator visible, if it exists.\n     */\n    show() {\n        if (this.container) {\n            this.container.style.display = 'block';\n        }\n    }\n\n    /**\n     * Hides the motion control indicator, if it exists.\n     */\n    hide() {\n        if (this.container) {\n            this.container.style.display = 'none';\n        }\n    }\n\n    /**\n     * Creates the DOM elements for the motion control indicator.\n     * @private\n     */\n    _create() {\n        this.container.innerHTML = `\n            <div class=\"motion-indicator ${this.options.position}\">\n                <div class=\"tilt-indicator ${this.options.position}\">\n                    <div class=\"dot\"></div>\n                    <div class=\"arrow up ${this.options.position}\">\\u25B2\\uFE0E</div>\n                    <div class=\"arrow down ${this.options.position}\">\\u25BC\\uFE0E</div>\n                    <div class=\"arrow left ${this.options.position}\">\\u25C0\\uFE0E</div>\n                    <div class=\"arrow right ${this.options.position}\">\\u25B6\\uFE0E</div>\n                </div>\n                ${this.options.showInfo ? `\n                <div class=\"info\">\n                    <p>Direction: <span class=\"direction-value\">None</span></p>\n                    <p>Beta: <span class=\"beta-value\">0.00</span>°</p>\n                    <p>Gamma: <span class=\"gamma-value\">0.00</span>°</p>\n                </div>\n                ` : ''}\n            </div>\n        `;\n\n        this.dot = this.container.querySelector('.dot');\n        this.arrows = this.container.querySelectorAll('.arrow');\n        this.directionValue = this.container.querySelector('.direction-value');\n        this.betaValue = this.container.querySelector('.beta-value');\n        this.gammaValue = this.container.querySelector('.gamma-value');\n\n        this._addStyles();\n    }\n\n    /**\n     * Adds the necessary styles for the motion control indicator.\n     * @private\n     */\n    _addStyles() {\n        const style = document.createElement('style');\n        style.textContent = `\n            .motion-indicator {\n                display: flex;\n                justify-content: space-between;\n                align-items: center;\n            }\n            .motion-indicator.corner {\n                position: fixed;\n                bottom: 20px;\n                right: 20px;\n                background: white;\n                padding: 10px;\n                border-radius: 10px;\n                box-shadow: 0 0 10px rgba(0,0,0,0.1);\n            }\n            .tilt-indicator {\n                width: 150px;\n                height: 150px;\n                border: 2px solid #ccc;\n                border-radius: 10px;\n                position: relative;\n                overflow: hidden;\n            }\n            .tilt-indicator.corner {\n                width: 100px;\n                height: 100px;\n            }\n            .dot {\n                width: 20px;\n                height: 20px;\n                background: blue;\n                border-radius: 50%;\n                position: absolute;\n                top: 50%;\n                left: 50%;\n                transform: translate(-50%, -50%);\n                transition: transform 0.1s ease;\n            }\n            .arrow {\n                position: absolute;\n                color: #ccc;\n                font-size: 24px;\n                transition: color 0.3s ease;\n            }\n            .arrow.up { top: 10px; left: 50%; transform: translateX(-50%); }\n            .arrow.down { bottom: 10px; left: 50%; transform: translateX(-50%); }\n            .arrow.left { left: 10px; top: 50%; transform: translateY(-50%); }\n            .arrow.right { right: 10px; top: 50%; transform: translateY(-50%); }\n            .arrow.active { color: green; }\n            .arrow.up.corner { top: 5px; }\n            .arrow.down.corner { bottom: 5px; }\n            .arrow.left.corner { left: 5px; }\n            .arrow.right.corner { right: 5px; }\n            .info {\n                text-align: left;\n                margin-left: 20px;\n            }\n            .info p {\n                margin: 5px 0;\n            }\n            .direction-value {\n                display: inline-block;\n                padding: 2px 8px;\n                border-radius: 4px;\n                transition: background-color 0.3s ease;\n            }\n            .direction-value.highlight {\n                background-color: #ffd700;\n            }\n        `;\n        document.head.appendChild(style);\n    }\n}\n\n/**\n * Calculates the motion control based on the current and last device orientation,\n * as well as the time between updates to prevent overly frequent updates.\n *\n * @param {{ beta: number, gamma: number }} currentOrientation - current device orientation\n * @param {{ beta: number, gamma: number }} lastOrientation - last device orientation\n * @param {number} currentUpdateTime - timestamp of the current update\n * @param {number} lastUpdateTime - timestamp of the last update\n *\n * @returns {string|null} direction - calculated direction (UP, DOWN, LEFT, RIGHT),\n *                        or null if no significant motion or if the update is too soon\n */\nexport function calculateMotionControl(currentOrientation, lastOrientation, currentUpdateTime, lastUpdateTime) {\n    // ensure we are not updating too frequently\n    if (currentUpdateTime - lastUpdateTime < INPUT.MOTION_THROTTLE_TIME_MS) {\n        return null;\n    }\n\n    // calculate change since last update\n    const recentChange = {\n        beta: currentOrientation.beta - lastOrientation.beta,\n        gamma: currentOrientation.gamma - lastOrientation.gamma\n    };\n\n    return isSignificantMotion(recentChange) ? getDirectionFromOrientation(recentChange) : null;\n}\n\n/**\n * Determines if a change in device orientation is significant enough to trigger a direction change.\n * Filters out small, unintentional device movements so we respond only to deliberate motions.\n * @param {Object} orientationChange - change in device orientation\n * @param {number} orientationChange.beta - change in beta (x-axis rotation) in degrees\n * @param {number} orientationChange.gamma - change in gamma (y-axis rotation) in degrees\n    * @returns {boolean} true if the motion is considered significant; false otherwise\n * @private\n */\nfunction isSignificantMotion(orientationChange) {\n    const threshold = INPUT.MOTION_SENSITIVITY;\n    return Math.abs(orientationChange.beta) > threshold || Math.abs(orientationChange.gamma) > threshold;\n}\n\n/**\n* Determine direction based on orientation change.\n* @param {{ beta: number, gamma: number }} orientationChange - the change in device orientation\n* @returns {string | null} determined direction or null\n* @private\n*/\nfunction getDirectionFromOrientation(orientationChange) {\n    let direction = null;\n    if (Math.abs(orientationChange.beta) > Math.abs(orientationChange.gamma)) {\n        direction = orientationChange.beta < 0 ? DIRECTION_UP : DIRECTION_DOWN;\n    } else {\n        direction = orientationChange.gamma < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;\n    }\n    return direction;\n}\n","import { MotionControlIndicator, calculateMotionControl } from './motion';\n\nfunction initDebugPage() {\n    const container = document.getElementById('motionIndicator');\n    if (!container) {\n        console.error('motion indicator container not found');\n        return;\n    }\n\n    const indicator = new MotionControlIndicator(container, {\n        showInfo: true,\n        position: 'inline'\n    });\n\n    let lastOrientation = null;\n    let lastOrientationUpdateTime = null;\n    let snakeDirection = null;\n\n    if (window.DeviceOrientationEvent) {\n        if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {\n            const button = document.getElementById('requestPermission');\n            if (button instanceof HTMLButtonElement) {\n                button.style.display = 'block';\n                button.addEventListener('click', requestOrientationPermission);\n            }\n        } else {\n            window.addEventListener('deviceorientation', handleOrientation);\n        }\n    } else {\n        showError(\"sorry, your browser doesn't support Device Orientation\");\n    }\n\n    function requestOrientationPermission() {\n        DeviceOrientationEvent.requestPermission()\n            .then(permissionState => {\n                if (permissionState === 'granted') {\n                    window.addEventListener('deviceorientation', handleOrientation);\n                    hideError();\n\n                    const button = document.getElementById('requestPermission');\n                    if (button instanceof HTMLButtonElement) {\n                        button.style.display = 'none';\n                    }\n                } else {\n                    showError('permission to access device orientation was denied.');\n                }\n            })\n            .catch(console.error);\n    }\n\n    function handleOrientation(event) {\n        const currentUpdateTime = Date.now();\n        const currentOrientation = {\n            beta: event.beta || 0,\n            gamma: event.gamma || 0\n        };\n\n        if (!lastOrientation) {\n            lastOrientation = { ...currentOrientation };\n        }\n\n        const direction = calculateMotionControl(\n            currentOrientation,\n            lastOrientation,\n            currentUpdateTime,\n            lastOrientationUpdateTime\n        );\n\n        if (direction) {\n            snakeDirection = direction;\n            console.log('direction changed:', snakeDirection);\n\n            lastOrientationUpdateTime = currentUpdateTime;\n            lastOrientation = currentOrientation;\n        }\n\n        indicator.update(currentOrientation, snakeDirection);\n    }\n\n    function showError(message) {\n        const errorElement = document.getElementById('errorMessage');\n        if (errorElement) {\n            errorElement.textContent = message;\n        }\n    }\n\n    function hideError() {\n        const errorElement = document.getElementById('errorMessage');\n        if (errorElement) {\n            errorElement.textContent = '';\n        }\n    }\n}\n\ndocument.addEventListener('DOMContentLoaded', initDebugPage);\n"],"names":["DIRECTION_LEFT","DIRECTION_RIGHT","DIRECTION_DOWN","INPUT","BOARD","CTRL_PANEL_HEIGHT","MARGIN_SIZE","NUM_STEPS_ACROSS_CANVAS","DEFAULT_BACKGROUND_COLOR","DEFAULT_BORDER_COLOR","TELEPORT_BORDER_COLOR","TELEPORT_BACKGROUND_COLOR","FILTERS","NONE","PAUSE","ENDGAME","SNAKE","INITIAL_LENGTH","DEFAULT_COLOR","PHASE_BORDER_COLOR","ITEM","FOOD_COLOR","FOOD_BORDER_COLOR","PHASE_COLOR","TELEPORT_COLOR","PHASE_SCORE_THRESHOLD","TELEPORT_SCORE_THRESHOLD","BASE_PHASE_PROBABILITY","BASE_TELEPORT_PROBABILITY","BASE_VOLATILE_FOOD_PROBABILITY","GAME","SCORE_INCREMENT","SCORE_THRESHOLD_FOR_VOLATILE_FOOD","SPEED_MS__ARROW","SPEED_MS__MOTION","SWIPE_SENSITIVITY","MOTION_SENSITIVITY","MOTION_THROTTLE_TIME_MS","CANVAS","GAME_TEXT_COLOR","HIGH_SCORE_TEXT_COLOR","PAUSE_BTN_COLOR","EXCLAMATION_BTN_COLOR","GAME_TEXT_FONT_FAMILY","GAME_TEXT_FONT_SIZE","STATE","LOCAL_STORAGE_KEY_HIGH_SCORE","LOCAL_STORAGE_KEY_GAME_SPEED","ERROR","MESSAGE_FONT","MESSAGE_COLOR","MESSAGE_BACKGROUND","MotionControlIndicator","constructor","container","options","this","showInfo","position","_create","update","orientation","direction","beta","gamma","maxTilt","tiltX","Math","min","max","tiltY","dotPx","dot","HTMLDivElement","style","transform","arrows","forEach","arrow","classList","remove","activeArrow","querySelector","toLowerCase","add","directionValue","HTMLSpanElement","textContent","setTimeout","betaValue","toFixed","gammaValue","show","display","hide","innerHTML","querySelectorAll","_addStyles","document","createElement","head","appendChild","calculateMotionControl","currentOrientation","lastOrientation","currentUpdateTime","lastUpdateTime","recentChange","orientationChange","threshold","abs","isSignificantMotion","getDirectionFromOrientation","addEventListener","getElementById","console","error","indicator","lastOrientationUpdateTime","snakeDirection","window","DeviceOrientationEvent","requestPermission","button","HTMLButtonElement","then","permissionState","handleOrientation","errorElement","hideError","showError","catch","event","Date","now","log","message"],"mappings":"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"}