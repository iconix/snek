{"version":3,"file":"debug__orientation.min.js","sources":["../src/js/config.js","../src/js/direction.js","../src/js/motion.js","../src/js/debug__orientation.js"],"sourcesContent":["export const GAME_CONFIG = {\n    BOARD: {\n        CTRL_PANEL_HEIGHT: 50,  // pixels\n        MARGIN_SIZE: 20,  // pixels\n        NUM_STEPS_ACROSS_CANVAS: 30,\n        DEFAULT_BACKGROUND_COLOR: 'white',\n        DEFAULT_BORDER_COLOR: 'darkgreen',\n        TELEPORT_BORDER_COLOR: 'blue',\n        TELEPORT_BACKGROUND_COLOR: '#e2f1fa',  // a light blue\n        FILTERS: {\n            NONE: 'none',\n            PAUSE: 'contrast(1.4) sepia(1)',\n            ENDGAME: 'grayscale(0.8) blur(0.5px)',\n        },\n    },\n\n    SNAKE: {\n        INITIAL_LENGTH: 5,\n        DEFAULT_COLOR: 'lightgreen',\n        DEFAULT_BORDER_COLOR: 'darkgreen',\n        PHASE_BORDER_COLOR: 'violet',\n    },\n\n    ITEM: {\n        FOOD_COLOR: 'red',\n        FOOD_BORDER_COLOR: 'darkred',\n        PHASE_COLOR: 'orchid',\n        PHASE_BORDER_COLOR: 'violet',\n        TELEPORT_COLOR: 'blue',\n        TELEPORT_BORDER_COLOR: 'darkblue',\n        PHASE_SCORE_THRESHOLD: 150,\n        TELEPORT_SCORE_THRESHOLD: 50,\n        BASE_PHASE_PROBABILITY: 0.1,\n        BASE_TELEPORT_PROBABILITY: 0.1,\n        BASE_VOLATILE_FOOD_PROBABILITY: 0.01,\n    },\n\n    GAME: {\n        SCORE_INCREMENT: 10,\n        SCORE_THRESHOLD_FOR_VOLATILE_FOOD: 100,\n    },\n\n    INPUT: {\n        GAME_SPEED_MS__ARROW: 100,\n        GAME_SPEED_MS__MOTION: 125,     // slow down game since harder with motion controls\n        SWIPE_SENSITIVITY: 10,          // delta of pixels needed to consider touch mvmt a 'swipe'\n        MOTION_SENSITIVITY: 15,         // degree of motion needed to consider a device mvmt as intentional\n        MOTION_THROTTLE_TIME_MS: 100,   // min time between motion control updates to prevent over-sensitivity\n        MOTION_DEADZONE: 2,             // in degrees TODO:\n        DOMINANT_DIRECTION_THRESHOLD: 5,// TODO:\n    },\n\n    CANVAS: {\n        GAME_TEXT_COLOR: 'gray',\n        HIGH_SCORE_TEXT_COLOR: 'goldenrod',\n        PAUSE_BTN_COLOR: 'darkkhaki',\n        EXCLAMATION_BTN_COLOR: 'darkkhaki',\n        GAME_TEXT_FONT_FAMILY: '\"Saira\", serif',\n        GAME_TEXT_FONT_SIZE: 50,\n    },\n\n    STATE: {\n        LOCAL_STORAGE_KEY_HIGH_SCORE: 'highScore',\n        LOCAL_STORAGE_KEY_GAME_SPEED: 'gameSpeed',\n    },\n\n    ERROR: {\n        // ERROR_MESSAGE_DURATION: 5000,\n        MESSAGE_FONT: '20px Arial',\n        MESSAGE_COLOR: 'red',\n        MESSAGE_BACKGROUND: 'rgba(0, 0, 0, 0.7)',\n    },\n};\n","export const DIRECTION_LEFT = 'left';\nexport const DIRECTION_RIGHT = 'right';\nexport const DIRECTION_UP = 'up';\nexport const DIRECTION_DOWN = 'down';\n\n/**\n * @typedef {Object} Direction\n * @property {number} dx - change in x direction\n * @property {number} dy - change in y direction\n */\n\n/**\n * Object mapping direction strings to their corresponding Direction objects.\n * @type {Object.<string, Direction>}\n */\nexport const DIRECTIONS = {\n    [DIRECTION_LEFT]:  { dx: -1, dy: 0 },\n    [DIRECTION_RIGHT]: { dx: 1,  dy: 0 },\n    [DIRECTION_UP]:    { dx: 0,  dy: -1 },\n    [DIRECTION_DOWN]:  { dx: 0,  dy: 1 },\n};\n\n/**\n * Gets the Direction object for a given direction string.\n * @param {string} direction - direction string\n * @returns {Direction | null} Direction object or null if not found\n */\nexport function getDirection(direction) {\n    return DIRECTIONS[direction.toLowerCase()] || null;\n}\n\n/**\n * Checks if two directions are opposite to each other.\n * @param {Direction} dir1 - first direction\n * @param {Direction} dir2 - second direction\n * @returns {boolean} true if the directions are opposite; false otherwise\n */\nexport function isOppositeDirection(dir1, dir2) {\n    return dir1.dx === -dir2.dx && dir1.dy === -dir2.dy;\n}\n\n/**\n * Normalizes a direction vector to have a magnitude of 1.\n * @param {number} dx - x component of the direction\n * @param {number} dy - y component of the direction\n * @returns {Direction} normalized direction\n */\nexport function normalizeDirection(dx, dy) {\n    const magnitude = Math.max(Math.abs(dx), Math.abs(dy));\n    if (magnitude === 0) {\n        return { dx: 0, dy: 0 };\n    }\n    return { dx: dx / magnitude, dy: dy / magnitude };\n}\n","import { GAME_CONFIG } from './config';\nimport { DIRECTION_DOWN, DIRECTION_LEFT, DIRECTION_RIGHT, DIRECTION_UP } from './direction';\n\nconst { INPUT } = GAME_CONFIG;\n\nexport class MotionControlIndicator {\n    constructor(container, options = {}) {\n        this.container = container;\n        this.options = {\n            showInfo: true,\n            position: 'inline',\n            ...options\n        };\n        this.create();\n    }\n\n    create() {\n        this.container.innerHTML = `\n            <div class=\"motion-indicator ${this.options.position}\">\n                <div class=\"tilt-indicator ${this.options.position}\">\n                    <div class=\"dot\"></div>\n                    <div class=\"arrow up ${this.options.position}\">▲</div>\n                    <div class=\"arrow down ${this.options.position}\">▼</div>\n                    <div class=\"arrow left ${this.options.position}\">◀</div>\n                    <div class=\"arrow right ${this.options.position}\">▶</div>\n                </div>\n                ${this.options.showInfo ? `\n                <div class=\"info\">\n                    <p>Direction: <span class=\"direction-value\">None</span></p>\n                    <p>Sensitivity: <span class=\"sensitivity-value\">1.00</span></p>\n                    <p>Beta: <span class=\"beta-value\">0.00</span>°</p>\n                    <p>Gamma: <span class=\"gamma-value\">0.00</span>°</p>\n                </div>\n                ` : ''}\n            </div>\n        `;\n\n        this.dot = this.container.querySelector('.dot');\n        this.arrows = this.container.querySelectorAll('.arrow');\n        this.directionValue = this.container.querySelector('.direction-value');\n        this.sensitivityValue = this.container.querySelector('.sensitivity-value');\n        this.betaValue = this.container.querySelector('.beta-value');\n        this.gammaValue = this.container.querySelector('.gamma-value');\n\n        this.addStyles();\n    }\n\n    addStyles() {\n        const style = document.createElement('style');\n        style.textContent = `\n            .motion-indicator {\n                display: flex;\n                justify-content: space-between;\n                align-items: center;\n            }\n            .motion-indicator.corner {\n                position: fixed;\n                bottom: 20px;\n                right: 20px;\n                background: white;\n                padding: 10px;\n                border-radius: 10px;\n                box-shadow: 0 0 10px rgba(0,0,0,0.1);\n            }\n            .tilt-indicator {\n                width: 150px;\n                height: 150px;\n                border: 2px solid #ccc;\n                border-radius: 10px;\n                position: relative;\n                overflow: hidden;\n            }\n            .tilt-indicator.corner {\n                width: 100px;\n                height: 100px;\n            }\n            .dot {\n                width: 20px;\n                height: 20px;\n                background: blue;\n                border-radius: 50%;\n                position: absolute;\n                top: 50%;\n                left: 50%;\n                transform: translate(-50%, -50%);\n                transition: transform 0.1s ease;\n            }\n            .arrow {\n                position: absolute;\n                color: #ccc;\n                font-size: 24px;\n                transition: color 0.3s ease;\n            }\n            .arrow.up { top: 10px; left: 50%; transform: translateX(-50%); }\n            .arrow.down { bottom: 10px; left: 50%; transform: translateX(-50%); }\n            .arrow.left { left: 10px; top: 50%; transform: translateY(-50%); }\n            .arrow.right { right: 10px; top: 50%; transform: translateY(-50%); }\n            .arrow.active { color: green; }\n            .arrow.up.corner { top: 5px; }\n            .arrow.down.corner { bottom: 5px; }\n            .arrow.left.corner { left: 5px; }\n            .arrow.right.corner { right: 5px; }\n            .info {\n                text-align: left;\n                margin-left: 20px;\n            }\n            .info p {\n                margin: 5px 0;\n            }\n        `;\n        document.head.appendChild(style);\n    }\n\n    update(orientation, direction, sensitivity) {\n        const { beta, gamma } = orientation;\n        const maxTilt = 30;\n        const tiltX = Math.min(Math.max(gamma, -maxTilt), maxTilt) / maxTilt;\n        const tiltY = Math.min(Math.max(beta, -maxTilt), maxTilt) / maxTilt;\n\n        const dotPx = this.options.position === 'corner' ? 40 : 60;\n        this.dot.style.transform = `translate(${tiltX * dotPx}px, ${tiltY * dotPx}px)`;\n\n        this.arrows.forEach(arrow => arrow.classList.remove('active'));\n        if (direction) {\n            this.container.querySelector(`.arrow.${direction.toLowerCase()}`).classList.add('active');\n        }\n\n        if (this.options.showInfo) {\n            this.directionValue.textContent = direction || 'None';\n            this.sensitivityValue.textContent = sensitivity.toFixed(2);\n            this.betaValue.textContent = beta.toFixed(2);\n            this.gammaValue.textContent = gamma.toFixed(2);\n        }\n    }\n}\n\nexport function calculateMotionControl(currentOrientation, initialOrientation, lastOrientation, sensitivityMultiplier) {\n    if (!initialOrientation) {\n        return { direction: null, sensitivity: 1, orientationChange: { beta: 0, gamma: 0 } };\n    }\n\n    // calculate change relative to initial orientation\n    const totalChange = {\n        beta: currentOrientation.beta - initialOrientation.beta,\n        gamma: currentOrientation.gamma - initialOrientation.gamma\n    };\n\n    // calculate change since last update\n    const recentChange = {\n        beta: currentOrientation.beta - lastOrientation.beta,\n        gamma: currentOrientation.gamma - lastOrientation.gamma\n    };\n\n    // update sensitivity based on total change from initial position\n    const magnitudeChange = Math.sqrt(totalChange.beta ** 2 + totalChange.gamma ** 2);\n    const newSensitivityMultiplier = 1 + (magnitudeChange / 45);\n\n    // apply deadzone to recent change\n    const adjustedDeadzone = INPUT.MOTION_DEADZONE / newSensitivityMultiplier;\n    if (Math.abs(recentChange.beta) <= adjustedDeadzone) recentChange.beta = 0;\n    if (Math.abs(recentChange.gamma) <= adjustedDeadzone) recentChange.gamma = 0;\n\n    // determine dominant direction based on recent change\n    const direction = getDirectionFromOrientation(recentChange);\n\n    return {\n        direction,\n        sensitivity: newSensitivityMultiplier,\n        orientationChange: recentChange\n    };\n}\n\nexport function isSignificantMotion(orientationChange, sensitivityMultiplier) {\n    const threshold = INPUT.MOTION_SENSITIVITY / sensitivityMultiplier;\n    return Math.abs(orientationChange.beta) > threshold || Math.abs(orientationChange.gamma) > threshold;\n}\n\n/**\n* Determine direction based on orientation change.\n* @param {{ beta: number, gamma: number }} orientationChange - the change in device orientation\n* @returns {string | null} determined direction or null\n* @private\n*/\nfunction getDirectionFromOrientation(orientationChange) {\n    let direction = null;\n\n    // determine dominant direction based on recent change\n    const absBeta = Math.abs(orientationChange.beta);\n    const absGamma = Math.abs(orientationChange.gamma);\n\n    if (absBeta > absGamma && absBeta - absGamma > INPUT.DOMINANT_DIRECTION_THRESHOLD) {\n        direction = orientationChange.beta < 0 ? DIRECTION_UP : DIRECTION_DOWN;\n    } else if (absGamma > absBeta && absGamma - absBeta > INPUT.DOMINANT_DIRECTION_THRESHOLD) {\n        direction = orientationChange.gamma < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;\n    }\n\n    return direction;\n}\n","import { MotionControlIndicator, calculateMotionControl, isSignificantMotion } from './motion';\n\nfunction initDebugPage() {\n    const container = document.getElementById('motionIndicator');\n    if (!container) {\n        console.error('Motion indicator container not found');\n        return;\n    }\n\n    const indicator = new MotionControlIndicator(container, {\n        showInfo: true,\n        position: 'inline'\n    });\n\n    let initialOrientation = null;\n    let lastOrientation = null;\n    let sensitivityMultiplier = 1;\n\n    if (window.DeviceOrientationEvent) {\n        if (typeof DeviceOrientationEvent.requestPermission === 'function') {\n            const button = document.getElementById('requestPermission');\n            button.style.display = 'block';\n            button.addEventListener('click', requestOrientationPermission);\n        } else {\n            window.addEventListener('deviceorientation', handleOrientation);\n        }\n    } else {\n        showError(\"Sorry, your browser doesn't support Device Orientation\");\n    }\n\n    function requestOrientationPermission() {\n        DeviceOrientationEvent.requestPermission()\n            .then(permissionState => {\n                if (permissionState === 'granted') {\n                    window.addEventListener('deviceorientation', handleOrientation);\n                    hideError();\n                    document.getElementById('requestPermission').style.display = 'none';\n                } else {\n                    showError('Permission to access device orientation was denied.');\n                }\n            })\n            .catch(console.error);\n    }\n\n    function handleOrientation(event) {\n        const currentOrientation = {\n            beta: event.beta || 0,\n            gamma: event.gamma || 0\n        };\n\n        if (!initialOrientation) {\n            initialOrientation = { ...currentOrientation };\n            lastOrientation = { ...currentOrientation };\n        }\n\n        const { direction, sensitivity, orientationChange } = calculateMotionControl(\n            currentOrientation,\n            initialOrientation,\n            lastOrientation,\n            sensitivityMultiplier\n        );\n\n        sensitivityMultiplier = sensitivity;\n\n        if (direction && isSignificantMotion(orientationChange, sensitivityMultiplier)) {\n            // in the game, this is where we would change the snake's direction\n            console.log('Direction change:', direction);\n        }\n\n        indicator.update(currentOrientation, direction, sensitivityMultiplier);\n\n        lastOrientation = currentOrientation;\n    }\n\n    function showError(message) {\n        const errorElement = document.getElementById('errorMessage');\n        if (errorElement) {\n            errorElement.textContent = message;\n        }\n    }\n\n    function hideError() {\n        const errorElement = document.getElementById('errorMessage');\n        if (errorElement) {\n            errorElement.textContent = '';\n        }\n    }\n}\n\ndocument.addEventListener('DOMContentLoaded', initDebugPage);\n"],"names":["DIRECTION_LEFT","DIRECTION_RIGHT","DIRECTION_DOWN","INPUT","BOARD","CTRL_PANEL_HEIGHT","MARGIN_SIZE","NUM_STEPS_ACROSS_CANVAS","DEFAULT_BACKGROUND_COLOR","DEFAULT_BORDER_COLOR","TELEPORT_BORDER_COLOR","TELEPORT_BACKGROUND_COLOR","FILTERS","NONE","PAUSE","ENDGAME","SNAKE","INITIAL_LENGTH","DEFAULT_COLOR","PHASE_BORDER_COLOR","ITEM","FOOD_COLOR","FOOD_BORDER_COLOR","PHASE_COLOR","TELEPORT_COLOR","PHASE_SCORE_THRESHOLD","TELEPORT_SCORE_THRESHOLD","BASE_PHASE_PROBABILITY","BASE_TELEPORT_PROBABILITY","BASE_VOLATILE_FOOD_PROBABILITY","GAME","SCORE_INCREMENT","SCORE_THRESHOLD_FOR_VOLATILE_FOOD","GAME_SPEED_MS__ARROW","GAME_SPEED_MS__MOTION","SWIPE_SENSITIVITY","MOTION_SENSITIVITY","MOTION_THROTTLE_TIME_MS","MOTION_DEADZONE","DOMINANT_DIRECTION_THRESHOLD","CANVAS","GAME_TEXT_COLOR","HIGH_SCORE_TEXT_COLOR","PAUSE_BTN_COLOR","EXCLAMATION_BTN_COLOR","GAME_TEXT_FONT_FAMILY","GAME_TEXT_FONT_SIZE","STATE","LOCAL_STORAGE_KEY_HIGH_SCORE","LOCAL_STORAGE_KEY_GAME_SPEED","ERROR","MESSAGE_FONT","MESSAGE_COLOR","MESSAGE_BACKGROUND","MotionControlIndicator","constructor","container","options","this","showInfo","position","create","innerHTML","dot","querySelector","arrows","querySelectorAll","directionValue","sensitivityValue","betaValue","gammaValue","addStyles","style","document","createElement","textContent","head","appendChild","update","orientation","direction","sensitivity","beta","gamma","maxTilt","tiltX","Math","min","max","tiltY","dotPx","transform","forEach","arrow","classList","remove","toLowerCase","add","toFixed","calculateMotionControl","currentOrientation","initialOrientation","lastOrientation","sensitivityMultiplier","orientationChange","totalChange","recentChange","newSensitivityMultiplier","sqrt","adjustedDeadzone","abs","absBeta","absGamma","getDirectionFromOrientation","addEventListener","getElementById","console","error","indicator","window","DeviceOrientationEvent","requestPermission","button","display","then","permissionState","handleOrientation","errorElement","hideError","showError","catch","event","threshold","isSignificantMotion","log","message"],"mappings":"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"}