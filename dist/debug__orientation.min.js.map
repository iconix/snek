{"version":3,"file":"debug__orientation.min.js","sources":["../src/js/config.js","../src/js/direction.js","../src/js/motion.js","../src/js/debug__orientation.js"],"sourcesContent":["export const GAME_CONFIG = {\n    BOARD: {\n        CTRL_PANEL_HEIGHT: 50,  // pixels\n        MARGIN_SIZE: 20,  // pixels\n        NUM_STEPS_ACROSS_CANVAS: 30,\n        DEFAULT_BACKGROUND_COLOR: 'white',\n        DEFAULT_BORDER_COLOR: 'darkgreen',\n        TELEPORT_BORDER_COLOR: 'blue',\n        TELEPORT_BACKGROUND_COLOR: '#e2f1fa',  // a light blue\n        FILTERS: {\n            NONE: 'none',\n            PAUSE: 'contrast(1.4) sepia(1)',\n            ENDGAME: 'grayscale(0.8) blur(0.5px)',\n        },\n    },\n\n    SNAKE: {\n        INITIAL_LENGTH: 5,\n        DEFAULT_COLOR: 'lightgreen',\n        DEFAULT_BORDER_COLOR: 'darkgreen',\n        PHASE_BORDER_COLOR: 'violet',\n    },\n\n    ITEM: {\n        FOOD_COLOR: 'red',\n        FOOD_BORDER_COLOR: 'darkred',\n        PHASE_COLOR: 'orchid',\n        PHASE_BORDER_COLOR: 'violet',\n        TELEPORT_COLOR: 'blue',\n        TELEPORT_BORDER_COLOR: 'darkblue',\n        PHASE_SCORE_THRESHOLD: 150,\n        TELEPORT_SCORE_THRESHOLD: 50,\n        BASE_PHASE_PROBABILITY: 0.1,\n        BASE_TELEPORT_PROBABILITY: 0.1,\n        BASE_VOLATILE_FOOD_PROBABILITY: 0.01,\n    },\n\n    GAME: {\n        SCORE_INCREMENT: 10,\n        SCORE_THRESHOLD_FOR_VOLATILE_FOOD: 100,\n        SPEED_MS__ARROW: 100,\n        SPEED_MS__MOTION: 125,          // slow down game since harder with motion controls\n    },\n\n    INPUT: {\n        SWIPE_SENSITIVITY: 10,          // delta of pixels needed to consider touch mvmt a 'swipe'\n        MOTION_SENSITIVITY: 15,         // degree of motion needed to consider a device mvmt as intentional\n        MOTION_THROTTLE_TIME_MS: 100,   // min time between motion control updates to prevent over-sensitivity\n        MOTION_DEADZONE: 2,             // in degrees TODO:\n        DOMINANT_DIRECTION_THRESHOLD: 5,// TODO:\n    },\n\n    CANVAS: {\n        GAME_TEXT_COLOR: 'gray',\n        HIGH_SCORE_TEXT_COLOR: 'goldenrod',\n        PAUSE_BTN_COLOR: 'darkkhaki',\n        EXCLAMATION_BTN_COLOR: 'darkkhaki',\n        GAME_TEXT_FONT_FAMILY: '\"Saira\", serif',\n        GAME_TEXT_FONT_SIZE: 50,\n    },\n\n    STATE: {\n        LOCAL_STORAGE_KEY_HIGH_SCORE: 'highScore',\n        LOCAL_STORAGE_KEY_GAME_SPEED: 'gameSpeed',\n    },\n\n    ERROR: {\n        // ERROR_MESSAGE_DURATION: 5000,\n        MESSAGE_FONT: '20px Arial',\n        MESSAGE_COLOR: 'red',\n        MESSAGE_BACKGROUND: 'rgba(0, 0, 0, 0.7)',\n    },\n};\n","export const DIRECTION_LEFT = 'left';\nexport const DIRECTION_RIGHT = 'right';\nexport const DIRECTION_UP = 'up';\nexport const DIRECTION_DOWN = 'down';\n\n/**\n * @typedef {Object} Direction\n * @property {number} dx - change in x direction\n * @property {number} dy - change in y direction\n */\n\n/**\n * Object mapping direction strings to their corresponding Direction objects.\n * @type {Object.<string, Direction>}\n */\nexport const DIRECTIONS = {\n    [DIRECTION_LEFT]:  { dx: -1, dy: 0 },\n    [DIRECTION_RIGHT]: { dx: 1,  dy: 0 },\n    [DIRECTION_UP]:    { dx: 0,  dy: -1 },\n    [DIRECTION_DOWN]:  { dx: 0,  dy: 1 },\n};\n\n/**\n * Gets the Direction object for a given direction string.\n * @param {string} direction - direction string\n * @returns {Direction | null} Direction object or null if not found\n */\nexport function getDirection(direction) {\n    return DIRECTIONS[direction.toLowerCase()] || null;\n}\n\n/**\n * Checks if two directions are opposite to each other.\n * @param {Direction} dir1 - first direction\n * @param {Direction} dir2 - second direction\n * @returns {boolean} true if the directions are opposite; false otherwise\n */\nexport function isOppositeDirection(dir1, dir2) {\n    return dir1.dx === -dir2.dx && dir1.dy === -dir2.dy;\n}\n\n/**\n * Normalizes a direction vector to have a magnitude of 1.\n * @param {number} dx - x component of the direction\n * @param {number} dy - y component of the direction\n * @returns {Direction} normalized direction\n */\nexport function normalizeDirection(dx, dy) {\n    const magnitude = Math.max(Math.abs(dx), Math.abs(dy));\n    if (magnitude === 0) {\n        return { dx: 0, dy: 0 };\n    }\n    return { dx: dx / magnitude, dy: dy / magnitude };\n}\n","import { GAME_CONFIG } from './config';\nimport { DIRECTION_DOWN, DIRECTION_LEFT, DIRECTION_RIGHT, DIRECTION_UP } from './direction';\n\nconst { INPUT } = GAME_CONFIG;\n\n/**\n * Represents a visual indicator for motion controls.\n */\nexport class MotionControlIndicator {\n\n    /**\n     * @param {HTMLDivElement} container - container element to render the indicator in\n     * @param {Object} [options={}] - configuration options for the indicator\n     * @param {boolean} [options.showInfo=true] - whether to show additional information\n     * @param {string} [options.position='inline'] - position of the indicator ('inline' or 'corner')\n     */\n    constructor(container, options = {}) {\n        this.container = container;\n        this.options = {\n            showInfo: true,\n            position: 'inline',\n            ...options\n        };\n        this._create();\n    }\n\n    /**\n     * Updates the motion control indicator based on the current orientation and direction.\n     * @param {{ beta: number, gamma: number }} orientation - current device orientation\n     * @param {string|null} direction - current direction of movement (UP, DOWN, LEFT, RIGHT, or null)\n     * TODO: sensitivity\n     */\n    update(orientation, direction, sensitivity) {\n        const { beta, gamma } = orientation;\n        const maxTilt = 30;\n        const tiltX = Math.min(Math.max(gamma, -maxTilt), maxTilt) / maxTilt;\n        const tiltY = Math.min(Math.max(beta, -maxTilt), maxTilt) / maxTilt;\n\n        const dotPx = this.options.position === 'corner' ? 40 : 60;\n        if (this.dot instanceof HTMLDivElement) {\n            this.dot.style.transform = `translate(${tiltX * dotPx}px, ${tiltY * dotPx}px)`;\n        }\n\n        if (this.arrows) {\n            this.arrows.forEach(arrow => arrow.classList.remove('active'));\n        }\n        if (direction) {\n            const activeArrow = this.container.querySelector(`.arrow.${direction.toLowerCase()}`);\n            if (activeArrow instanceof HTMLDivElement) {\n                activeArrow.classList.add('active')\n            }\n\n            if (this.options.showInfo && this.directionValue instanceof HTMLSpanElement) {\n                if (this.directionValue.textContent !== direction) {\n                    this.directionValue.classList.add('highlight');\n                    this.directionValue.textContent = direction;\n                    setTimeout(() => {\n                        if (this.directionValue instanceof HTMLSpanElement) {\n                            this.directionValue.classList.remove('highlight');\n                        }\n                    }, 300);\n                }\n            }\n        }\n\n        if (this.options.showInfo) {\n            if (this.betaValue instanceof HTMLSpanElement) {\n                this.betaValue.textContent = beta.toFixed(2);\n            }\n            if (this.gammaValue instanceof HTMLSpanElement) {\n                this.gammaValue.textContent = gamma.toFixed(2);\n            }\n            if (this.sensitivityValue instanceof HTMLSpanElement) {\n                this.sensitivityValue.textContent = sensitivity.toFixed(2);\n            }\n        }\n    }\n\n    /**\n     * Makes the motion control indicator visible, if it exists.\n     */\n    show() {\n        if (this.container) {\n            this.container.style.display = 'block';\n        }\n    }\n\n    /**\n     * Hides the motion control indicator, if it exists.\n     */\n    hide() {\n        if (this.container) {\n            this.container.style.display = 'none';\n        }\n    }\n\n    /**\n     * Creates the DOM elements for the motion control indicator.\n     * @private\n     */\n    _create() {\n        this.container.innerHTML = `\n            <div class=\"motion-indicator ${this.options.position}\">\n                <div class=\"tilt-indicator ${this.options.position}\">\n                    <div class=\"dot\"></div>\n                    <div class=\"arrow up ${this.options.position}\">\\u25B2\\uFE0E</div>\n                    <div class=\"arrow down ${this.options.position}\">\\u25BC\\uFE0E</div>\n                    <div class=\"arrow left ${this.options.position}\">\\u25C0\\uFE0E</div>\n                    <div class=\"arrow right ${this.options.position}\">\\u25B6\\uFE0E</div>\n                </div>\n                ${this.options.showInfo ? `\n                <div class=\"info\">\n                    <p>Direction: <span class=\"direction-value\">None</span></p>\n                    <p>Sensitivity: <span class=\"sensitivity-value\">1.00</span></p>\n                    <p>Beta: <span class=\"beta-value\">0.00</span>°</p>\n                    <p>Gamma: <span class=\"gamma-value\">0.00</span>°</p>\n                </div>\n                ` : ''}\n            </div>\n        `;\n\n        this.dot = this.container.querySelector('.dot');\n        this.arrows = this.container.querySelectorAll('.arrow');\n        this.directionValue = this.container.querySelector('.direction-value');\n        this.sensitivityValue = this.container.querySelector('.sensitivity-value');\n        this.betaValue = this.container.querySelector('.beta-value');\n        this.gammaValue = this.container.querySelector('.gamma-value');\n\n        this._addStyles();\n    }\n\n    /**\n     * Adds the necessary styles for the motion control indicator.\n     * @private\n     */\n    _addStyles() {\n        const style = document.createElement('style');\n        style.textContent = `\n            .motion-indicator {\n                display: flex;\n                justify-content: space-between;\n                align-items: center;\n            }\n            .motion-indicator.corner {\n                position: fixed;\n                bottom: 20px;\n                right: 20px;\n                background: white;\n                padding: 10px;\n                border-radius: 10px;\n                box-shadow: 0 0 10px rgba(0,0,0,0.1);\n            }\n            .tilt-indicator {\n                width: 150px;\n                height: 150px;\n                border: 2px solid #ccc;\n                border-radius: 10px;\n                position: relative;\n                overflow: hidden;\n            }\n            .tilt-indicator.corner {\n                width: 100px;\n                height: 100px;\n            }\n            .dot {\n                width: 20px;\n                height: 20px;\n                background: blue;\n                border-radius: 50%;\n                position: absolute;\n                top: 50%;\n                left: 50%;\n                transform: translate(-50%, -50%);\n                transition: transform 0.1s ease;\n            }\n            .arrow {\n                position: absolute;\n                color: #ccc;\n                font-size: 24px;\n                transition: color 0.3s ease;\n            }\n            .arrow.up { top: 10px; left: 50%; transform: translateX(-50%); }\n            .arrow.down { bottom: 10px; left: 50%; transform: translateX(-50%); }\n            .arrow.left { left: 10px; top: 50%; transform: translateY(-50%); }\n            .arrow.right { right: 10px; top: 50%; transform: translateY(-50%); }\n            .arrow.active { color: green; }\n            .arrow.up.corner { top: 5px; }\n            .arrow.down.corner { bottom: 5px; }\n            .arrow.left.corner { left: 5px; }\n            .arrow.right.corner { right: 5px; }\n            .info {\n                text-align: left;\n                margin-left: 20px;\n            }\n            .info p {\n                margin: 5px 0;\n            }\n            .direction-value {\n                display: inline-block;\n                padding: 2px 8px;\n                border-radius: 4px;\n                transition: background-color 0.3s ease;\n            }\n            .direction-value.highlight {\n                background-color: #ffd700;\n            }\n        `;\n        document.head.appendChild(style);\n    }\n}\n\n/**\n * Calculates the motion control based on the current and last device orientation,\n * as well as the time between updates to prevent overly frequent updates.\n *\n * @param {{ beta: number, gamma: number }} currentOrientation - current device orientation\n * TODO: initialOrientation\n * @param {{ beta: number, gamma: number }} lastOrientation - last device orientation\n * @param {number} currentUpdateTime - timestamp of the current update\n * @param {number} lastUpdateTime - timestamp of the last update\n * TODO: sensitivityMultiplier\n *\n * @returns {string|null} direction - calculated direction (UP, DOWN, LEFT, RIGHT),\n *                        or null if no significant motion or if the update is too soon\n */\nexport function calculateMotionControl(currentOrientation, initialOrientation, lastOrientation, currentUpdateTime, lastUpdateTime, sensitivityMultiplier) {\n    if (!initialOrientation) {\n        return { direction: null, sensitivity: 1 };\n    }\n\n    // ensure we are not updating too frequently\n    if (currentUpdateTime - lastUpdateTime < INPUT.MOTION_THROTTLE_TIME_MS) {\n        return null;\n    }\n\n    // calculate change relative to initial orientation\n    const totalChange = {\n        beta: currentOrientation.beta - initialOrientation.beta,\n        gamma: currentOrientation.gamma - initialOrientation.gamma\n    };\n\n    // calculate change since last update\n    const recentChange = {\n        beta: currentOrientation.beta - lastOrientation.beta,\n        gamma: currentOrientation.gamma - lastOrientation.gamma\n    };\n\n    // update sensitivity based on total change from initial position\n    const magnitudeChange = Math.sqrt(totalChange.beta ** 2 + totalChange.gamma ** 2);\n    const newSensitivityMultiplier = 1 + (magnitudeChange / 45);\n\n    // apply deadzone to recent change\n    const adjustedDeadzone = INPUT.MOTION_DEADZONE / newSensitivityMultiplier;\n    if (Math.abs(recentChange.beta) <= adjustedDeadzone) recentChange.beta = 0;\n    if (Math.abs(recentChange.gamma) <= adjustedDeadzone) recentChange.gamma = 0;\n\n    // determine dominant direction based on recent change\n    const direction = isSignificantMotion(recentChange, sensitivityMultiplier) ? getDirectionFromOrientation(recentChange) : null;\n\n    return {\n        direction,\n        sensitivity: newSensitivityMultiplier\n    };\n}\n\n/**\n * Determines if a change in device orientation is significant enough to trigger a direction change.\n * Filters out small, unintentional device movements so we respond only to deliberate motions.\n * @param {Object} orientationChange - change in device orientation\n * @param {number} orientationChange.beta - change in beta (x-axis rotation) in degrees\n * @param {number} orientationChange.gamma - change in gamma (y-axis rotation) in degrees\n    * @returns {boolean} true if the motion is considered significant; false otherwise\n * TODO: sensitivityMultiplier\n * @private\n */\nfunction isSignificantMotion(orientationChange, sensitivityMultiplier) {\n    const threshold = INPUT.MOTION_SENSITIVITY / sensitivityMultiplier;\n    return Math.abs(orientationChange.beta) > threshold || Math.abs(orientationChange.gamma) > threshold;\n}\n\n/**\n* Determine direction based on orientation change.\n* @param {{ beta: number, gamma: number }} orientationChange - the change in device orientation\n* @returns {string | null} determined direction or null\n* @private\n*/\nfunction getDirectionFromOrientation(orientationChange) {\n    let direction = null;\n\n    // determine dominant direction based on recent change\n    const absBeta = Math.abs(orientationChange.beta);\n    const absGamma = Math.abs(orientationChange.gamma);\n\n    if (absBeta > absGamma && absBeta - absGamma > INPUT.DOMINANT_DIRECTION_THRESHOLD) {\n        direction = orientationChange.beta < 0 ? DIRECTION_UP : DIRECTION_DOWN;\n    } else if (absGamma > absBeta && absGamma - absBeta > INPUT.DOMINANT_DIRECTION_THRESHOLD) {\n        direction = orientationChange.gamma < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;\n    }\n    return direction;\n}\n","import { MotionControlIndicator, calculateMotionControl } from './motion';\n\nfunction initDebugPage() {\n    const container = document.getElementById('motionIndicator');\n    if (!(container instanceof HTMLDivElement)) {\n        console.error('motion indicator container not found');\n        return;\n    }\n\n    const indicator = new MotionControlIndicator(container, {\n        showInfo: true,\n        position: 'inline'\n    });\n\n    let initialOrientation = null;\n    let lastOrientation = null;\n    let lastOrientationUpdateTime = null;\n    let snakeDirection = null;\n    let sensitivityMultiplier = 1;\n\n    if (window.DeviceOrientationEvent) {\n        if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {\n            const button = document.getElementById('requestPermission');\n            if (button instanceof HTMLButtonElement) {\n                button.style.display = 'block';\n                button.addEventListener('click', requestOrientationPermission);\n            }\n        } else {\n            window.addEventListener('deviceorientation', handleOrientation);\n        }\n    } else {\n        showError(\"sorry, your browser doesn't support Device Orientation\");\n    }\n\n    function requestOrientationPermission() {\n        DeviceOrientationEvent.requestPermission()\n            .then(permissionState => {\n                if (permissionState === 'granted') {\n                    window.addEventListener('deviceorientation', handleOrientation);\n                    hideError();\n\n                    const button = document.getElementById('requestPermission');\n                    if (button instanceof HTMLButtonElement) {\n                        button.style.display = 'none';\n                    }\n                } else {\n                    showError('permission to access device orientation was denied.');\n                }\n            })\n            .catch(console.error);\n    }\n\n    function handleOrientation(event) {\n        const currentUpdateTime = Date.now();\n        const currentOrientation = {\n            beta: event.beta || 0,\n            gamma: event.gamma || 0\n        };\n\n        if (!initialOrientation) {\n            initialOrientation = { ...currentOrientation };\n            lastOrientation = { ...currentOrientation };\n        }\n\n        const { direction, sensitivity } = calculateMotionControl(\n            currentOrientation,\n            lastOrientation,\n            currentUpdateTime,\n            lastOrientationUpdateTime\n        );\n\n        sensitivityMultiplier = sensitivity;\n\n        if (direction) {\n            snakeDirection = direction;\n            console.log('direction changed:', snakeDirection);\n\n            lastOrientationUpdateTime = currentUpdateTime;\n            lastOrientation = currentOrientation;\n        }\n\n        indicator.update(currentOrientation, snakeDirection, sensitivityMultiplier);\n    }\n\n    function showError(message) {\n        const errorElement = document.getElementById('errorMessage');\n        if (errorElement) {\n            errorElement.textContent = message;\n        }\n    }\n\n    function hideError() {\n        const errorElement = document.getElementById('errorMessage');\n        if (errorElement) {\n            errorElement.textContent = '';\n        }\n    }\n}\n\ndocument.addEventListener('DOMContentLoaded', initDebugPage);\n"],"names":["DIRECTION_LEFT","DIRECTION_RIGHT","DIRECTION_DOWN","INPUT","BOARD","CTRL_PANEL_HEIGHT","MARGIN_SIZE","NUM_STEPS_ACROSS_CANVAS","DEFAULT_BACKGROUND_COLOR","DEFAULT_BORDER_COLOR","TELEPORT_BORDER_COLOR","TELEPORT_BACKGROUND_COLOR","FILTERS","NONE","PAUSE","ENDGAME","SNAKE","INITIAL_LENGTH","DEFAULT_COLOR","PHASE_BORDER_COLOR","ITEM","FOOD_COLOR","FOOD_BORDER_COLOR","PHASE_COLOR","TELEPORT_COLOR","PHASE_SCORE_THRESHOLD","TELEPORT_SCORE_THRESHOLD","BASE_PHASE_PROBABILITY","BASE_TELEPORT_PROBABILITY","BASE_VOLATILE_FOOD_PROBABILITY","GAME","SCORE_INCREMENT","SCORE_THRESHOLD_FOR_VOLATILE_FOOD","SPEED_MS__ARROW","SPEED_MS__MOTION","SWIPE_SENSITIVITY","MOTION_SENSITIVITY","MOTION_THROTTLE_TIME_MS","MOTION_DEADZONE","DOMINANT_DIRECTION_THRESHOLD","CANVAS","GAME_TEXT_COLOR","HIGH_SCORE_TEXT_COLOR","PAUSE_BTN_COLOR","EXCLAMATION_BTN_COLOR","GAME_TEXT_FONT_FAMILY","GAME_TEXT_FONT_SIZE","STATE","LOCAL_STORAGE_KEY_HIGH_SCORE","LOCAL_STORAGE_KEY_GAME_SPEED","ERROR","MESSAGE_FONT","MESSAGE_COLOR","MESSAGE_BACKGROUND","MotionControlIndicator","constructor","container","options","this","showInfo","position","_create","update","orientation","direction","sensitivity","beta","gamma","maxTilt","tiltX","Math","min","max","tiltY","dotPx","dot","HTMLDivElement","style","transform","arrows","forEach","arrow","classList","remove","activeArrow","querySelector","toLowerCase","add","directionValue","HTMLSpanElement","textContent","setTimeout","betaValue","toFixed","gammaValue","sensitivityValue","show","display","hide","innerHTML","querySelectorAll","_addStyles","document","createElement","head","appendChild","calculateMotionControl","currentOrientation","initialOrientation","lastOrientation","currentUpdateTime","lastUpdateTime","sensitivityMultiplier","totalChange","recentChange","newSensitivityMultiplier","sqrt","adjustedDeadzone","abs","orientationChange","threshold","isSignificantMotion","absBeta","absGamma","getDirectionFromOrientation","addEventListener","getElementById","console","error","indicator","lastOrientationUpdateTime","snakeDirection","window","DeviceOrientationEvent","requestPermission","button","HTMLButtonElement","then","permissionState","handleOrientation","errorElement","hideError","showError","catch","event","Date","now","log","message"],"mappings":"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"}